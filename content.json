{"meta":{"title":"WenBin-Zhang","subtitle":"前端小白","description":"Runoob of web front end~","author":"WenBin-Zhang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-04T06:01:41.000Z","updated":"2020-05-04T06:11:18.655Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-04T04:06:47.000Z","updated":"2020-05-04T06:10:31.409Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-04T06:00:34.000Z","updated":"2020-05-04T06:11:10.983Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-05-04T02:55:50.638Z","updated":"2020-05-04T02:31:35.585Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"事件委托","slug":"事件委托","date":"2020-05-26T13:26:59.000Z","updated":"2020-05-26T13:31:40.124Z","comments":true,"path":"2020/05/26/事件委托/","link":"","permalink":"http://yoursite.com/2020/05/26/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"DOM","slug":"JavaScript/DOM","permalink":"http://yoursite.com/categories/JavaScript/DOM/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"DOM事件","slug":"DOM事件","date":"2020-05-26T11:04:01.000Z","updated":"2020-05-26T13:26:40.440Z","comments":true,"path":"2020/05/26/DOM事件/","link":"","permalink":"http://yoursite.com/2020/05/26/DOM%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"DOM事件的级别 DOM0 element.onclick = function(){} DOM2 element.addEventListener(&#39;click&#39;,function(){},false) DOM3 element.addEventListener(&#39;keyup&#39;,function(){},false) DOM3 和 DOM2 相比只是添加了更多的事件类型，这里没有DOM1是因为DOM1没有实质性的内容。 DOM事件模型 事件模型有两个部分，捕获和冒泡。 1.何为DOMDOM是“Document Object Model”的缩写，中文译为“文档对象模型”。它是一种跨平台、跨语言的编程接口，将HTML，XHTML，XML文档映射成树形结构，树的每一个节点都是一个对象。正因如此，面向对象的编程语言（如javascript）可以通过DOM对HTML，XHTML，XML文档进行操作。对于HTML文档来说，它的根结点为document对象，HTML元素为element对象，HTML元素的属性为attr对象。 2.何为DOM事件及如何对其作出响应在浏览网页时，我们常常需要页面对用户的操作作出响应，比如点击“阅读全文”后我们期望页面展示被折叠的文本，按下回车键后浏览器提交已填好的表单。用户的各种操作都是“事件”。事件都是在对象上发生的，可能是DOM对象、BOM对象，等等。事件发生后，对象可能会作出响应，也有可能“无动于衷”。我们希望DOM元素对事件作出响应，一般而言有两种方法：i.事件属性事件属性是一种特殊的属性，它的值规定了对应事件发生时需要执行的javascript脚本。例： 1&lt;button onclick=\"console.log('button clicked!')\"&gt;&lt;/button&gt; 上面为button标签添加了事件属性onclick，其值为”console.log(‘button clicked!’)”，它规定了当元素被鼠标点击时，控制台输出’button clicked’。ii.addEventListener()方法EventTarget.addEventListener()方法将指定的监听器注册到EventTarget上，当该对象触发指定的事件时，指定的回调函数就会被执行。EventTarget可以是element对象,document对象或者任何其他支持事件的对象。例： 1234567&lt;!--html文件中--&gt;&lt;button id='mybutton'&gt;&lt;/button&gt;&lt;script&gt; var mybutton=document.getElementById('mybutton'); mybutton.addEventListener('click',function(e)&#123;console.log('button clicked!');&#125;);&lt;/script&gt; 上例为button元素注册了click事件的监听器，并规定事件时触发控制台输出’button clicked’。 3.DOM事件模型在讲解DOM事件模型前，再用一个例子作为引入。请看下面的html文件： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;DOM Event Model&lt;/title&gt; &lt;style&gt; div&#123;position: absolute;&#125; #outer&#123; top: 100px; left: 100px; width: 600px; height: 400px; background-color: #aff; &#125; #inner1,#inner2&#123; top: 50px; width: 200px; height: 300px; background-color: #f9a; &#125; #inner1&#123;left: 50px;&#125; #inner2&#123;left: 350px;&#125; #core&#123; left: 50px; top: 50px; width: 100px; height: 150px; background-color: #f50; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='outer' onclick=\"console.log(this.id)\"&gt; &lt;div id='inner1' onclick=\"console.log(this.id)\"&gt;&lt;/div&gt; &lt;div id='inner2' onclick=\"console.log(this.id)\"&gt; &lt;div id='core' onclick=\"console.log(this.id)\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里为id分别为outer,inner1,inner2,core的4个元素定义了事件属性，元素被点击后将在控制台输出它的id。现在问题来了：如果我点击core元素，控制台将会输出什么？点击core元素时，由于core元素包含在inner2元素里，inner2元素同样被点击了;同理，inner2元素包含在outer元素里，那么outer元素也被点击了。这种情况下哪一个元素的click事件将会被触发,或者说三者都被触发？如果说三者都被触发，那么又是以怎样的顺序被触发？我在火狐浏览器做了一次实验，控制台输出结果如下： 123coreinner2outer 也就是说，三者的事件都被触发了，且是“由内向外”触发的。下面我们再做一个有趣的实验：我们将上面的html文件再做一个小小的改动，将core元素的样式 1left: 50px; 改为 1left: -250px; 此时观察页面我们会发现，尽量core是inner2的子节点，但由于我们定义了“怪异”的样式，它跑到了inner1里面。现在我们再次用鼠标点击core，观察控制台的输出： 123coreinner2outer 和刚才的结果一模一样！尽管表面上inner1似乎被点击了，但它的click事件并没有触发;反而是看似未被点击的inner2元素的click事件被触发了。仿佛core元素的click事件被触发后，click事件一层一层向上“传播”给了父节点。为了解释刚才的实验结果，是时候开始讲解DOM事件模型了。当一个事件发生时，事件会在DOM树中进行传播。传播分为两个阶段： 捕获阶段在此阶段，事件从根结点（即document结点）开始向下传播，直到事件源所在元素。 冒泡阶段在此阶段，事件从事件源开始向上传播，直到根结点。 拿刚才的例子来说，事件传播的顺序为：document捕获-&gt;html捕获-&gt;body捕获-&gt;outer捕获-&gt;inner2捕获-&gt;core捕获-&gt;core冒泡-&gt;inner2冒泡-&gt;outer冒泡-&gt;html冒泡-&gt;document冒泡 对于事件属性，默认在冒泡阶段触发事件。如果用addEventListener()方法注册监听器，则可以指定在捕获阶段还是冒泡阶段触发事件：如果最后一个参数为false（默认值），则在冒泡阶段触发事件;如果为true，则在捕获阶段触发事件。 一般来说，我们推荐采用addEventListener()方法来注册监听器，而尽量不用事件属性。因为事件属性不利于行为与结构的分离，使代码难以维护。 DOM事件流一个完整的事件流包含三个阶段：捕获阶段（Capturing Phase）、事件处理阶段（Target Phase）、事件冒泡阶段（Bubbling Phase）。 从用户触发元素到浏览器执行响应事件这整个过程，就是事件流。 DOM事件捕获的具体流程Event对象的常见应用 event.preventDefault() 阻止事件的默认行为，例如&lt;a&gt;&lt;/a&gt;标签的默认点击行为是跳转到新的页面，使用event.preventDefault()可以阻止这种跳转行为。 1234567&lt;a id=\"target\" href=\"www.baidu.com\"&gt;跳转到百度&lt;/a&gt;&lt;script&gt; let target = document.querySelector(\"#target\"); target.addEventListener(function(event)&#123; event.preventDefault(); //阻止跳转行为 &#125;)&lt;/script&gt; event.stopPropagation() 阻止冒泡行为：点击子元素时不会出发父元素的点击事件。 event.stopImmediatePropagation() 当一个DOM元素绑定了多个响应事件后，可以通过此方法阻止指定响应事件的执行。 event.currentTarget event.target 事件委托时用到的最多，当一个父级元素下面的子元素非常多，并且子元素都有各自的点击事件，普通做法就是一个一个添加响应事件，这种做法并不是理想的做法，浪费大量的内存，以及过多的事件注册会导致用户体验很差。 此时我们就可以采用事件委托的方式，将所有子元素的事件都绑定在父级元素上，然后通过event.target判断具体是点击的哪一个子元素，然后执行相应的事件处理函数即可。 事件委托详情参见： 自定义事件12345678910// 自定义一个Event对象let eve = new Event('custome');// 绑定自定义事件dom.addEventListener('custome',function()&#123; console.log('custome');&#125;)// 执行自定义事件dom.dispatchEvent(eve);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"HTML","slug":"JavaScript/HTML","permalink":"http://yoursite.com/categories/JavaScript/HTML/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"css盒模型","slug":"css盒模型","date":"2020-05-25T01:51:26.000Z","updated":"2020-05-25T13:43:57.117Z","comments":true,"path":"2020/05/25/css盒模型/","link":"","permalink":"http://yoursite.com/2020/05/25/css%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"标准盒模型：FireFox、Chrome等标准浏览器默认盒模型，元素内容的宽高即元素宽高，不包括元素的内边距、外边距和边框。 IE盒模型: IE浏览器（IE9以下版本）的盒模型，元素宽高等于元素内容宽高+元素内边距宽高+元素边框的粗细。 首先要提一点：元素的大小不是指元素的宽高，只有先了解这一点才能正确理解盒模型，元素大小永远都是content + padding + border + margin，但是元素宽高就不是固定的了。 先来一张维基百科里面盒模型的图片： 如上图所示，一个元素一共分为 content、padding、border、margin 四个部分。 标准盒模型的宽 = 内容的宽（即上图的width）; 标准盒模型的高 = 内容的高（即上图的height）； IE盒模型的宽 = 内容的宽 + 左内边距 + 右内边距 + 左边框的宽度 + 右边框的宽度； 对应上图：content-width + padding-left + padding-right + border-left + border-right IE盒模型的高 = 内容的高 + 顶部内边距 + 底部内边距 + 顶部边框的高度 + 底部边框的高度； 对应上图：content-height + padding-top + padding-bottom + border-top + border-bottom box-sizing属性目前的标准浏览器渲染引擎都是使用标准盒子模型规则解析渲染元素，但是我们可以通过box-sizing属性手动指定浏览器的解析渲染方式。 值 描述 content-box 标准盒子模型。元素的宽高等于元素内容的宽高。元素的内边距，边框不参与到元素宽高的计算中。 border-box IE盒子模型。元素的宽高等于元素内容的宽/高+左右内边距的宽/高+边框的宽/高。 inherit 从父元素继承box-sizing属性的值。","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"layout","slug":"css/layout","permalink":"http://yoursite.com/categories/css/layout/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"javascript获取元素的宽高的四种方式","slug":"javascript获取元素的宽高的四种方式","date":"2020-05-24T09:48:32.000Z","updated":"2020-05-24T10:32:15.874Z","comments":true,"path":"2020/05/24/javascript获取元素的宽高的四种方式/","link":"","permalink":"http://yoursite.com/2020/05/24/javascript%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%BD%E9%AB%98%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"通过 javascript 获取元素的宽高是经常使用的，在此总结一些常见的方法，以及各个方法的区别，和适用场景。 一、dom.style.width/height通过 DOM 元素的 style 属性可以获取到元素的内联样式，如果元素的宽高是内联样式规定的可以采用这个方法。如果元素的宽高不是由内联样式指定，此方法无效。 1234567&lt;div id=\"targt\" style=\"width:100px;height:100px;background-color:thistle\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\"); console.log(dom.style.width); // 100px&lt;/script&gt; PS:此方法只能获取到元素的内联样式指定的宽高，如果是行内样式或者外联样式是获取不到的。 二、dom.currentStyle.width/height获取的是元素经过浏览器渲染以后的及时宽高，比较第一种更全面不局限于内联样式。但是此方法只对IE浏览器有效。 12345678910111213141516&lt;style&gt; #target&#123; width:100px; height:100px; background-color: thistle; &#125;&lt;/style&gt;&lt;div id=\"target\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\") console.log(dom.currentStyle.width); // IE浏览器下: 100px&lt;/script&gt; 三、window.getComputedStyle(dom).width/height这个原理跟第二种一样，是获取元素渲染以后的及时宽高，此方法适用的是标准浏览器Firefox、chrome等。 1234567891011121314151617&lt;style&gt; #target&#123; width:100px; height:100px; background-color: thistle; &#125;&lt;/style&gt;&lt;div id=\"target\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\") let width = window.getComputedStyle(dom).width; console.log(width); // 标准浏览器下: 100px;&lt;/script&gt; 四、dom.getBoundingClientRect().width/heightgetBoundingClientRect()这个api其实本事不是专门为了获取元素宽高而使用的，它主要是获取浏览器及时运行完以后一个dom元素的绝对位置信息，但是包含了元素宽高。返回了四个主要内容top、left、width、height。 1234567891011121314151617&lt;style&gt; #target&#123; width:100px; height:100px; background-color: thistle; &#125;&lt;/style&gt;&lt;div id=\"target\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\") let width = dom.getBoundingClientRect().width; console.log(width); // 100; 注意它只返回数值 100 而不是完整的 100px;&lt;/script&gt; getBoundingClientRect()完整返回值如下图所示：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"float布局","slug":"float布局","date":"2020-05-23T02:08:51.000Z","updated":"2020-05-23T08:58:56.449Z","comments":true,"path":"2020/05/23/float布局/","link":"","permalink":"http://yoursite.com/2020/05/23/float%E5%B8%83%E5%B1%80/","excerpt":"","text":"float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。 PS:假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 常见的取值 值 描述 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素正常显示。 inherit 从父元素继承float属性的值。 浮动原理设置了浮动属性的元素会脱离正常的文档流，相对于其它正常的元素浮动起来。浮动的参照边界是父级元素的边界或者是其它浮动元素的边界。如下图所示。 浮动的影响 不会影响未浮动的块级元素布局，但会影响内联元素的布局。 12345678910111213141516171819202122232425262728&lt;section&gt; &lt;style&gt; #container-one&#123; height: 200px; &#125; #container-one div&#123; width: 100px; height: 100px; &#125; #container-one span&#123; background-color: deepskyblue; &#125; .item-block&#123; background-color: thistle; &#125; .item-float&#123; background-color: wheat; &#125; .item-float-left&#123; float: left; &#125; &lt;/style&gt; &lt;article id=\"container-one\"&gt; &lt;div class=\"item-block\"&gt;&lt;/div&gt; &lt;span&gt;这是一个行内元素&lt;/span&gt; &lt;div class=\"item-float item-float-left\"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; 浮动后的元素可以设置宽度和高度，意味着内联元素浮动以后会变成 inline-block 元素 123456789101112131415161718192021222324&lt;section&gt; &lt;style&gt; #container-two&#123; width: 500px; height: 100px; background-color: darkcyan; &#125; #container-two span&#123; width: 200px; height: 100px; background-color: deepskyblue; &#125; #container-two .float&#123; float: left; background-color: wheat; &#125; &lt;/style&gt; &lt;article id=\"container-two\"&gt; &lt;span&gt;普通内联元素,无法设置宽高&lt;/span&gt; &lt;span class=\"float\"&gt;浮动后的内联元素，可以设置宽高&lt;/span&gt; &lt;/article&gt;&lt;/section&gt; 可能导致父元素高度坍塌 前面的示例都是对父元素设置了一个固定高度，如果不设置这个高度，正常来说父元素的高度将由子元素的高度撑开，但是浮动后的子元素是脱离了正常的文档流的，这种情况下是不会为父元素提供可使用的高度的。 123456789101112131415161718192021222324252627&lt;section&gt; &lt;style&gt; #container-three&#123; width: 500px; background-color: darkcyan; &#125; #container-three .float&#123; width: 100px; height: 100px; &#125; #container-three .float-left&#123; float: left; background-color: thistle; &#125; #container-three .float-right&#123; float: right; background-color: wheat; &#125; &lt;/style&gt; &lt;article id=\"container-three\"&gt; &lt;div class=\"float float-left\"&gt;左浮动子元素&lt;/div&gt; &lt;div class=\"float float-right\"&gt;右浮动子元素&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 如上图所示，浮动的子元素还是可以找到正确的参照边界（父元素的左右边框），但是通过审查元素会发现父级元素 &lt;article id=&quot;contaiiner&gt;&lt;/article&gt;&quot; 的高度是0。这就是元素浮动导致的父级元素高度坍塌现象。 闭合浮动 清除浮动和闭合浮动的区别： 清除浮动是指的CSS中的属性: clear: left|right|both|none; 闭合浮动是指的是，通过一定方法，减少或消除在布局过程中由于使用浮动属性带来的问题，例如上面提到的父级元素高度崩塌等问题。 闭合浮动常用的几种方式： 1、在浮动元素末尾添加一个空 div 设置其 clear 属性值为 both，例如 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; 2、父级元素定义 overflow:hidden 3、对父级元素也使用浮动，就是说让所有元素都浮动起来，这种方法只建议用于理论，实际操作这种方式不太显示。 4、对父级元素设置伪元素，即 ：after 1234567.class-name:after&#123; display: block; height: 0; clear: both; visibility: hidden; content: \"\"&#125; 如上图所示：闭合浮动后父级元素的高度出来了，这样即可解决高度崩塌的问题了。","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"layout","slug":"css/layout","permalink":"http://yoursite.com/categories/css/layout/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"配置npm安装全局模块时的路径","slug":"配置npm安装全局模块时的路径","date":"2020-05-22T04:09:35.000Z","updated":"2020-05-22T05:46:40.332Z","comments":true,"path":"2020/05/22/配置npm安装全局模块时的路径/","link":"","permalink":"http://yoursite.com/2020/05/22/%E9%85%8D%E7%BD%AEnpm%E5%AE%89%E8%A3%85%E5%85%A8%E5%B1%80%E6%A8%A1%E5%9D%97%E6%97%B6%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"配置原因: 在执行 npm install &#39;包名&#39; -g 命令全局安装的时候，会默认将模块安装在 C:\\Users\\用户名\\AppData\\Roaming路径下的npm和npm_cache 中，不方便管理并且占用 C 盘空间。 解决方案：配置自定义的全局模块安装目录。 手动创建两个文件夹 node_global 和 node_cache 。 如果你的 Node.js 没有安装在 C 盘，你可以直接在 Node.js 的安装目录下创建这两个文件。 如果你的 Node.js 是安装在 C 盘的，那么不建议你直接在其安装目录下创建，因为这样做意义不大，包文件还是存放在 C 盘。这种情况你可以在 C 盘以外你认为比较好管理的地方创建 node_global 和 node_cache 这两个目录。 上图的npm-install-package 也是我手动创建的。总之哪里好管理你就先建在那里。 在 cmd 命令行下执行如下配置命令： 123npm config set prefix \"D:\\npm-install-package\\node_global\"npm config set cache \"D:\\npm-install-package\\node_cache\" 执行完毕后，需要去配置环境变量： 环境变量 – 系统变量：新建一个变量 NODE_PATH ，值为 D:\\npm-install-package\\node_global\\node_modules，如下图所示： 环境变量 – 用户变量：编辑用户变量里面的Path，将原来的 npm 路径 (“C:\\Users\\用户名\\AppData\\Roaming\\npm”) 改为 D:\\npm-install-package\\node_global 如下图所示： 配置已经完成，可以全局安装一个包测试一下。 cmd 下执行 npm install webpack -g 全局安装 webpack 如下图所示： 安装完毕后查看我们的node_cache 和 node_global 文件夹，如下图所示： 最后 cmd 任意目录下输入 webpack -v 检查是否安装成功，如下图所示： 可能遇到的问题 首先是 cnpm 的问题：有些兄弟之前为了装包快是自己配置了淘宝镜像的，但是当我们配置完了上面的内容会发现 cnpm 用不了了 cnpm 不是系统内部或外部命令。这是由于我们更改了环境变量导致的，因为原来的 cnpm 是装在了 “C:\\Users\\用户名\\AppData\\Roaming\\npm” 里的，后来改变了该路径，所以系统找不到我们的 cnpm 很正常。 此时你只需要重新执行 npm install cnpm -g --registry=https://registry.npm.taobao.org 就行了。执行以后在我们的 node_global 下可以看见如下图所示： 并且可以在 node_global\\node_modules 下看见我们安装的包，如下图所示： 同理之前其它的包有可能也用不了了，只需重新安装就好。","categories":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/categories/npm/"},{"name":"Node.js","slug":"npm/Node-js","permalink":"http://yoursite.com/categories/npm/Node-js/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"ES6（一）-let和const命令","slug":"ES6（一）-let和const命令","date":"2020-05-16T14:34:04.000Z","updated":"2020-05-17T02:30:47.953Z","comments":true,"path":"2020/05/16/ES6（一）-let和const命令/","link":"","permalink":"http://yoursite.com/2020/05/16/ES6%EF%BC%88%E4%B8%80%EF%BC%89-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1. let 命令 ES6 新增 let 命令，用于声明变量。用来解决 var 命令带来的弊端，是新一代的标准。 let 命令与 var 命令的区别： 只作用于 let 命令所在的块级作用域。 1234567&#123; var a = 1; let b = 2;&#125;a // 1b // ReferenceError: a is not defined; 上面代码中 {} 中为一个单独的块级作用域，在这个作用域中用 var 声明的变量，在该作用域以外还是可以被正常访问，而在该作用域中用 let 命令声明的变量，在该作用域外部引用会报错。 不存在变量提升。 变量提升：即变量在未声明之前就可以使用，值为undefined。这种现象就是变量提升。 12345console.log(a); // undefinedvar a = 1;console.log(b); // ReferenceErrorlet b = 2; 上面代码中使用 var 命令声明的变量，在声明之前已经可以调用，只不过输出的值为 undefined 。而使用 let 命令声明的变量，在声明之前不可以调用，会报错。 js 预编译阶段：此阶段进行变量和函数的声明（特指声明式函数），但是不对变量进行赋值，变量的默认值为 undefined 。这也是变量提示的原因所在 js 代码执行阶段：此阶段对变量进行赋值和函数的调用。 变量提升的实质：js 在预编译阶段将所有的声明提到代码最前面，此时内存中有一个存放 undefined 的地方，将这些声明的变量或函数全部指向该内存地址。因为变量的实质就是一个内存地址，用来指向某个我们赋值给它的数据。 上面是 js 的执行顺序，使用 let 命令声明的变量，在预编译阶段 js 解析引擎是不会对其进行变量提升操作，不会将他提到代码最前面，所以用 let 命令声明的变量，在 let 前面出现时它的值并不是 undefined而是一段解析引擎不认识的一个非法变量，这个变量不是一个有效的内存地址，所以解析引擎会直接抛出一个错误。 暂时性死区。 只要块级作用域内存在 let 命令，它所声明的变量就“绑定”(binding)这个区域，不在受外部影响。 在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。在语法上，成为“暂时性死区”（temporal dead zone, 简称 TDZ）。 123456var a = '123';if(true)&#123; a = '321'; // ReferenceError let a;&#125; 从上述代码可以看出，即使在 if 代码块前面声明了变量 a ，但在 if 代码块内部由于 let 命令的存在，所以代码块内部的变量 a 只认内部的 let 命令，只能在 let 命令之后使用，否则会报错，这就是暂时性死区。 不允许重复声明。 当使用 var 命令去声明变量时，可以重复声明，在语法这没有任何问题，解析引擎会将后面的声明覆盖掉前面的声明。但是 let 命令是在同一个块级作用域内是不允许重复声明的，var 也不行。 1234function()&#123; let a = 123; var a = 123;&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript的call、apply、bind函数的用法和区别","slug":"JavaScript的call、apply、bind函数的用法和区别","date":"2020-05-16T05:07:33.000Z","updated":"2020-05-16T06:10:34.145Z","comments":true,"path":"2020/05/16/JavaScript的call、apply、bind函数的用法和区别/","link":"","permalink":"http://yoursite.com/2020/05/16/JavaScript%E7%9A%84call%E3%80%81apply%E3%80%81bind%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、用法 这三个方法都是 JavaScript 函数原型链上的方法，每个函数都会自动继承这三个方法。 总的来说三者都是用来改变this指向的，可以实现在一个对象的成员函数调用其它对象的成员函数或者成员变量。 123456789101112131415161718let jack = &#123; name:'jack', age:'23'&#125;let tom = &#123; name:'tom', age:'20', printMessage: function()&#123; console.log('This is ' + this.name + ',he is ' + this.age) &#125;&#125;tom.printMessage.call(jack); // 结果：This is jack,he is 23.tom.printMessage.apply(jack); // 结果：This is jack,he is 23.tom.printMessage.bind(jack)(); // 结果：This is jack,he is 23.// 可以看见printMessage内部的this指向被改变，不在指向调用它的对象tom，而是指向了call、apply、bind传入的参数：对象jack。 二、区别 这三个方法，在用途上没有什么区别，关键是在用法上存在区别。体现在他们三者的参数列表和返回值。 12345678910111213141516171819202122232425let jack = &#123; name: 'jack', age: '23'&#125;let tom = &#123; name: 'tom', age: '20', printMessage: function(from,to)&#123; console.log('This is ' + this.name + ',he is ' + this.age + 'from' + from + ' to ' + to + '.') &#125;&#125;// call方法，接受多个参数，第一个参数为执行函数的this值，其余参数将会按顺序赋值给执行函数的参数列表tom.printMessage.call(jack,'Beijin','Shanghai');// This is jack,he is 23 from Beijin to Shanghai/* apply方法，接受两个参数，第一个参数为执行函数的this值，第二个参数是一个数组，数组元素将会按顺序赋值给执行函数的参数列表 */tom.printMessage.apply(jack,['Beijin','Shanghai']);// This is jack,he is 23 from Beijin to Shanghai/* bind方法，接受参数形式与call方法一致，但是返回的是一个新的函数，必须要手动调用一次才会执行。*/tom.printMessage.bind(jack,'Beijin','Shanghai')();// This is jack,he is 23 from Beijin to Shanghai","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript中i++和++i的区别","slug":"JavaScript中i-和-i的区别","date":"2020-05-11T10:47:21.000Z","updated":"2020-05-11T13:00:59.496Z","comments":true,"path":"2020/05/11/JavaScript中i-和-i的区别/","link":"","permalink":"http://yoursite.com/2020/05/11/JavaScript%E4%B8%ADi-%E5%92%8C-i%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、++ i 和 i ++简单介绍++ 运算符又称自增运算符，功能为将操作数自加 1。 ++ i 被称为前加加，++ 后面的变量执行自加操作，执行顺序为：先执行变量的自加操作，再引用变量的值。 i ++ 被称为后加加，++ 前面的变量执行自加操作，执行顺序为：先引用变量的值，在执行自加操作。 在实际代码中，如果加加语句是一个独立的语句，那么两者是完全相同的。比如： 123a ++; /*完全等价于*/ ++ a;// orfor(let i = 0; i &lt; 10; i ++)&#123;...&#125; /*两者是完全等价的*/ for(let i = 0; i &lt; 10 ; ++ i)&#123;...&#125; 上面两个示例 自增语句都是一个独立的语句，在这种情况下，++ i和i ++是完全等价的。 二、 ++ i 和 i ++ 使用时的区别当加加语句不是一个独立的语句，只是某一个语句的一部分，二者就有区别了。 i ++ 12345let i = 0;let j = i ++; //此时完整的语句为 let j = i ++;先执行变量赋值，再执行 ++ 操作先j = i = 0 后i = 1;let i = 0;while( i ++ &lt; 10); // 此时i是从0开始第一次比较，先判断 i &lt; 10,然后变量i再执行加加操作; ++ i 12345let i = 0;let j = ++ i; //此时完整的语句为 let j = ++ i;先执行 ++ 操作，再赋值变量：先i = 1后j = i = 1;let i = 0;while( ++ i &lt; 10); // 此时i是从1开始第一次比较,变量i先执行加加操作，再判断 i &lt; 10;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"operator","slug":"JavaScript/operator","permalink":"http://yoursite.com/categories/JavaScript/operator/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"operator","slug":"operator","permalink":"http://yoursite.com/tags/operator/"}]},{"title":"Vue-cli@3中使用bootstrap","slug":"vue-import-bootstrap","date":"2020-05-07T16:38:49.000Z","updated":"2020-05-08T16:21:49.562Z","comments":true,"path":"2020/05/08/vue-import-bootstrap/","link":"","permalink":"http://yoursite.com/2020/05/08/vue-import-bootstrap/","excerpt":"","text":"Vue-cli@3创建的项目中如何使用Bootstrap一、安装所需包 Bootstrap 是基于 jQuery 开发的，所以先安装 jQuery。 1$ cnpm install jquery -s 安装 Popper.js, BootStrap 内部有些嵌套组件，是依靠 Popper.js 来实现定位的。非必须安装如果你的项目会用到 BootStrap 中的类似于 下拉列表这样的组件，建议先提前安装 popper.js,否则可能报错。关于popper.js的介绍以及具体介绍如下。 Popper.js是一款功能强大的JS定位引擎。 站在原型链顶端的男人的博客 1$ cnpm install popper.js -s 安装 BootStrap 包。 1$ cnpm install bootstrap@3 -s 二、配置main.js 全局引入 bootstrap 和 jquery 注意导入时，import $ from &#39;jquery&#39; 要写在最前面。否则可能报错 三、配置 vue.config.js 在 vue-cli@3搭建的 vue 项目默认是不没有该文件的，需要在 package.json 的同级目录下手动创建。具体代码如下： 如果一切顺利，便可以使用了。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Bootstrap","slug":"Vue/Bootstrap","permalink":"http://yoursite.com/categories/Vue/Bootstrap/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-04T00:50:58.975Z","updated":"2020-05-04T04:10:45.365Z","comments":true,"path":"2020/05/04/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"DOM","slug":"JavaScript/DOM","permalink":"http://yoursite.com/categories/JavaScript/DOM/"},{"name":"HTML","slug":"JavaScript/HTML","permalink":"http://yoursite.com/categories/JavaScript/HTML/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"layout","slug":"css/layout","permalink":"http://yoursite.com/categories/css/layout/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/categories/npm/"},{"name":"Node.js","slug":"npm/Node-js","permalink":"http://yoursite.com/categories/npm/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"},{"name":"operator","slug":"JavaScript/operator","permalink":"http://yoursite.com/categories/JavaScript/operator/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Bootstrap","slug":"Vue/Bootstrap","permalink":"http://yoursite.com/categories/Vue/Bootstrap/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"operator","slug":"operator","permalink":"http://yoursite.com/tags/operator/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}