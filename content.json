{"meta":{"title":"WenBin-Zhang","subtitle":"前端小白","description":"Runoob of web front end~","author":"WenBin-Zhang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-04T06:01:41.000Z","updated":"2020-05-04T06:11:18.655Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-04T04:06:47.000Z","updated":"2020-05-04T06:10:31.409Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-04T06:00:34.000Z","updated":"2020-05-04T06:11:10.983Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-05-04T02:55:50.638Z","updated":"2020-05-04T02:31:35.585Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"配置npm安装全局模块时的路径","slug":"配置npm安装全局模块时的路径","date":"2020-05-22T04:09:35.000Z","updated":"2020-05-22T05:46:40.332Z","comments":true,"path":"2020/05/22/配置npm安装全局模块时的路径/","link":"","permalink":"http://yoursite.com/2020/05/22/%E9%85%8D%E7%BD%AEnpm%E5%AE%89%E8%A3%85%E5%85%A8%E5%B1%80%E6%A8%A1%E5%9D%97%E6%97%B6%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"配置原因: 在执行 npm install &#39;包名&#39; -g 命令全局安装的时候，会默认将模块安装在 C:\\Users\\用户名\\AppData\\Roaming路径下的npm和npm_cache 中，不方便管理并且占用 C 盘空间。 解决方案：配置自定义的全局模块安装目录。 手动创建两个文件夹 node_global 和 node_cache 。 如果你的 Node.js 没有安装在 C 盘，你可以直接在 Node.js 的安装目录下创建这两个文件。 如果你的 Node.js 是安装在 C 盘的，那么不建议你直接在其安装目录下创建，因为这样做意义不大，包文件还是存放在 C 盘。这种情况你可以在 C 盘以外你认为比较好管理的地方创建 node_global 和 node_cache 这两个目录。 上图的npm-install-package 也是我手动创建的。总之哪里好管理你就先建在那里。 在 cmd 命令行下执行如下配置命令： 123npm config set prefix \"D:\\npm-install-package\\node_global\"npm config set cache \"D:\\npm-install-package\\node_cache\" 执行完毕后，需要去配置环境变量： 环境变量 – 系统变量：新建一个变量 NODE_PATH ，值为 D:\\npm-install-package\\node_global\\node_modules，如下图所示： 环境变量 – 用户变量：编辑用户变量里面的Path，将原来的 npm 路径 (“C:\\Users\\用户名\\AppData\\Roaming\\npm”) 改为 D:\\npm-install-package\\node_global 如下图所示： 配置已经完成，可以全局安装一个包测试一下。 cmd 下执行 npm install webpack -g 全局安装 webpack 如下图所示： 安装完毕后查看我们的node_cache 和 node_global 文件夹，如下图所示： 最后 cmd 任意目录下输入 webpack -v 检查是否安装成功，如下图所示： 可能遇到的问题 首先是 cnpm 的问题：有些兄弟之前为了装包快是自己配置了淘宝镜像的，但是当我们配置完了上面的内容会发现 cnpm 用不了了 cnpm 不是系统内部或外部命令。这是由于我们更改了环境变量导致的，因为原来的 cnpm 是装在了 “C:\\Users\\用户名\\AppData\\Roaming\\npm” 里的，后来改变了该路径，所以系统找不到我们的 cnpm 很正常。 此时你只需要重新执行 npm install cnpm -g --registry=https://registry.npm.taobao.org 就行了。执行以后在我们的 node_global 下可以看见如下图所示： 并且可以在 node_global\\node_modules 下看见我们安装的包，如下图所示： 同理之前其它的包有可能也用不了了，只需重新安装就好。","categories":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/categories/npm/"},{"name":"Node.js","slug":"npm/Node-js","permalink":"http://yoursite.com/categories/npm/Node-js/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"ES6（一）-let和const命令","slug":"ES6（一）-let和const命令","date":"2020-05-16T14:34:04.000Z","updated":"2020-05-17T02:30:47.953Z","comments":true,"path":"2020/05/16/ES6（一）-let和const命令/","link":"","permalink":"http://yoursite.com/2020/05/16/ES6%EF%BC%88%E4%B8%80%EF%BC%89-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1. let 命令 ES6 新增 let 命令，用于声明变量。用来解决 var 命令带来的弊端，是新一代的标准。 let 命令与 var 命令的区别： 只作用于 let 命令所在的块级作用域。 1234567&#123; var a = 1; let b = 2;&#125;a // 1b // ReferenceError: a is not defined; 上面代码中 {} 中为一个单独的块级作用域，在这个作用域中用 var 声明的变量，在该作用域以外还是可以被正常访问，而在该作用域中用 let 命令声明的变量，在该作用域外部引用会报错。 不存在变量提升。 变量提升：即变量在未声明之前就可以使用，值为undefined。这种现象就是变量提升。 12345console.log(a); // undefinedvar a = 1;console.log(b); // ReferenceErrorlet b = 2; 上面代码中使用 var 命令声明的变量，在声明之前已经可以调用，只不过输出的值为 undefined 。而使用 let 命令声明的变量，在声明之前不可以调用，会报错。 js 预编译阶段：此阶段进行变量和函数的声明（特指声明式函数），但是不对变量进行赋值，变量的默认值为 undefined 。这也是变量提示的原因所在 js 代码执行阶段：此阶段对变量进行赋值和函数的调用。 变量提升的实质：js 在预编译阶段将所有的声明提到代码最前面，此时内存中有一个存放 undefined 的地方，将这些声明的变量或函数全部指向该内存地址。因为变量的实质就是一个内存地址，用来指向某个我们赋值给它的数据。 上面是 js 的执行顺序，使用 let 命令声明的变量，在预编译阶段 js 解析引擎是不会对其进行变量提升操作，不会将他提到代码最前面，所以用 let 命令声明的变量，在 let 前面出现时它的值并不是 undefined而是一段解析引擎不认识的一个非法变量，这个变量不是一个有效的内存地址，所以解析引擎会直接抛出一个错误。 暂时性死区。 只要块级作用域内存在 let 命令，它所声明的变量就“绑定”(binding)这个区域，不在受外部影响。 在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。在语法上，成为“暂时性死区”（temporal dead zone, 简称 TDZ）。 123456var a = '123';if(true)&#123; a = '321'; // ReferenceError let a;&#125; 从上述代码可以看出，即使在 if 代码块前面声明了变量 a ，但在 if 代码块内部由于 let 命令的存在，所以代码块内部的变量 a 只认内部的 let 命令，只能在 let 命令之后使用，否则会报错，这就是暂时性死区。 不允许重复声明。 当使用 var 命令去声明变量时，可以重复声明，在语法这没有任何问题，解析引擎会将后面的声明覆盖掉前面的声明。但是 let 命令是在同一个块级作用域内是不允许重复声明的，var 也不行。 1234function()&#123; let a = 123; var a = 123;&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript的call、apply、bind函数的用法和区别","slug":"JavaScript的call、apply、bind函数的用法和区别","date":"2020-05-16T05:07:33.000Z","updated":"2020-05-16T06:10:34.145Z","comments":true,"path":"2020/05/16/JavaScript的call、apply、bind函数的用法和区别/","link":"","permalink":"http://yoursite.com/2020/05/16/JavaScript%E7%9A%84call%E3%80%81apply%E3%80%81bind%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、用法 这三个方法都是 JavaScript 函数原型链上的方法，每个函数都会自动继承这三个方法。 总的来说三者都是用来改变this指向的，可以实现在一个对象的成员函数调用其它对象的成员函数或者成员变量。 123456789101112131415161718let jack = &#123; name:'jack', age:'23'&#125;let tom = &#123; name:'tom', age:'20', printMessage: function()&#123; console.log('This is ' + this.name + ',he is ' + this.age) &#125;&#125;tom.printMessage.call(jack); // 结果：This is jack,he is 23.tom.printMessage.apply(jack); // 结果：This is jack,he is 23.tom.printMessage.bind(jack)(); // 结果：This is jack,he is 23.// 可以看见printMessage内部的this指向被改变，不在指向调用它的对象tom，而是指向了call、apply、bind传入的参数：对象jack。 二、区别 这三个方法，在用途上没有什么区别，关键是在用法上存在区别。体现在他们三者的参数列表和返回值。 12345678910111213141516171819202122232425let jack = &#123; name: 'jack', age: '23'&#125;let tom = &#123; name: 'tom', age: '20', printMessage: function(from,to)&#123; console.log('This is ' + this.name + ',he is ' + this.age + 'from' + from + ' to ' + to + '.') &#125;&#125;// call方法，接受多个参数，第一个参数为执行函数的this值，其余参数将会按顺序赋值给执行函数的参数列表tom.printMessage.call(jack,'Beijin','Shanghai');// This is jack,he is 23 from Beijin to Shanghai/* apply方法，接受两个参数，第一个参数为执行函数的this值，第二个参数是一个数组，数组元素将会按顺序赋值给执行函数的参数列表 */tom.printMessage.apply(jack,['Beijin','Shanghai']);// This is jack,he is 23 from Beijin to Shanghai/* bind方法，接受参数形式与call方法一致，但是返回的是一个新的函数，必须要手动调用一次才会执行。*/tom.printMessage.bind(jack,'Beijin','Shanghai')();// This is jack,he is 23 from Beijin to Shanghai","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript中i++和++i的区别","slug":"JavaScript中i-和-i的区别","date":"2020-05-11T10:47:21.000Z","updated":"2020-05-11T13:00:59.496Z","comments":true,"path":"2020/05/11/JavaScript中i-和-i的区别/","link":"","permalink":"http://yoursite.com/2020/05/11/JavaScript%E4%B8%ADi-%E5%92%8C-i%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、++ i 和 i ++简单介绍++ 运算符又称自增运算符，功能为将操作数自加 1。 ++ i 被称为前加加，++ 后面的变量执行自加操作，执行顺序为：先执行变量的自加操作，再引用变量的值。 i ++ 被称为后加加，++ 前面的变量执行自加操作，执行顺序为：先引用变量的值，在执行自加操作。 在实际代码中，如果加加语句是一个独立的语句，那么两者是完全相同的。比如： 123a ++; /*完全等价于*/ ++ a;// orfor(let i = 0; i &lt; 10; i ++)&#123;...&#125; /*两者是完全等价的*/ for(let i = 0; i &lt; 10 ; ++ i)&#123;...&#125; 上面两个示例 自增语句都是一个独立的语句，在这种情况下，++ i和i ++是完全等价的。 二、 ++ i 和 i ++ 使用时的区别当加加语句不是一个独立的语句，只是某一个语句的一部分，二者就有区别了。 i ++ 12345let i = 0;let j = i ++; //此时完整的语句为 let j = i ++;先执行变量赋值，再执行 ++ 操作先j = i = 0 后i = 1;let i = 0;while( i ++ &lt; 10); // 此时i是从0开始第一次比较，先判断 i &lt; 10,然后变量i再执行加加操作; ++ i 12345let i = 0;let j = ++ i; //此时完整的语句为 let j = ++ i;先执行 ++ 操作，再赋值变量：先i = 1后j = i = 1;let i = 0;while( ++ i &lt; 10); // 此时i是从1开始第一次比较,变量i先执行加加操作，再判断 i &lt; 10;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"operator","slug":"JavaScript/operator","permalink":"http://yoursite.com/categories/JavaScript/operator/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"operator","slug":"operator","permalink":"http://yoursite.com/tags/operator/"}]},{"title":"Vue-cli@3中使用bootstrap","slug":"vue-import-bootstrap","date":"2020-05-07T16:38:49.000Z","updated":"2020-05-08T16:21:49.562Z","comments":true,"path":"2020/05/08/vue-import-bootstrap/","link":"","permalink":"http://yoursite.com/2020/05/08/vue-import-bootstrap/","excerpt":"","text":"Vue-cli@3创建的项目中如何使用Bootstrap一、安装所需包 Bootstrap 是基于 jQuery 开发的，所以先安装 jQuery。 1$ cnpm install jquery -s 安装 Popper.js, BootStrap 内部有些嵌套组件，是依靠 Popper.js 来实现定位的。非必须安装如果你的项目会用到 BootStrap 中的类似于 下拉列表这样的组件，建议先提前安装 popper.js,否则可能报错。关于popper.js的介绍以及具体介绍如下。 Popper.js是一款功能强大的JS定位引擎。 站在原型链顶端的男人的博客 1$ cnpm install popper.js -s 安装 BootStrap 包。 1$ cnpm install bootstrap@3 -s 二、配置main.js 全局引入 bootstrap 和 jquery 注意导入时，import $ from &#39;jquery&#39; 要写在最前面。否则可能报错 三、配置 vue.config.js 在 vue-cli@3搭建的 vue 项目默认是不没有该文件的，需要在 package.json 的同级目录下手动创建。具体代码如下： 如果一切顺利，便可以使用了。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Bootstrap","slug":"Vue/Bootstrap","permalink":"http://yoursite.com/categories/Vue/Bootstrap/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-04T00:50:58.975Z","updated":"2020-05-04T04:10:45.365Z","comments":true,"path":"2020/05/04/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/categories/npm/"},{"name":"Node.js","slug":"npm/Node-js","permalink":"http://yoursite.com/categories/npm/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"operator","slug":"JavaScript/operator","permalink":"http://yoursite.com/categories/JavaScript/operator/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Bootstrap","slug":"Vue/Bootstrap","permalink":"http://yoursite.com/categories/Vue/Bootstrap/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"operator","slug":"operator","permalink":"http://yoursite.com/tags/operator/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}