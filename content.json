{"meta":{"title":"WenBin-Zhang","subtitle":"前端小白","description":"Runoob of web front end~","author":"WenBin-Zhang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-04T06:01:41.000Z","updated":"2020-05-04T06:11:18.655Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-04T04:06:47.000Z","updated":"2020-05-04T06:10:31.409Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-04T06:00:34.000Z","updated":"2020-05-04T06:11:10.983Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-05-04T02:55:50.638Z","updated":"2020-05-04T02:31:35.585Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"js中判断对象的数据类型","slug":"js中判断对象的数据类型","date":"2020-07-04T06:31:36.000Z","updated":"2020-07-04T12:44:03.062Z","comments":true,"path":"2020/07/04/js中判断对象的数据类型/","link":"","permalink":"http://yoursite.com/2020/07/04/js%E4%B8%AD%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"一、利用 typeof 方法 ​ 这种方法只能用来判断如下几种数据类型eg: Number、Boolean、String、Undefined、Symbol、Function ​ typeof实现原理是利用js底层会在变量的机器码的低位1-3位存储其类型信息（真实性有待考察，因为目前还没有看到function的机器码，这无法解释typeof可以判断function） 000：对象 010：浮点数(就是Number，js里所有的数字其实都是以浮点数的形式存储的) 100：字符串 110：布尔 1：整数 1234567891011121314151617console.log(typeof 123) //numberconsole.log(typeof 'abc') //stringconsole.log(typeof undefined) //undefinedconsole.log(typeof false) //booleanconsole.log(typeof Symbol()) //symbol//最特别的我认为就是function，typeof居然是可以判断出function的consol.log(typeof function()&#123;&#125;) //function//但是用来判断非引用类型的对象，则统一返回object，特别注意这里的null也返回objectconsole.log(typeof []) //objectconsole.log(typeof &#123;&#125;) //object/////////////////////////////////////////////////////////////////console.log(typeof null) //object// 原因：null的所有机器码都是000/////////////////////////////////////////////////////////////////console.log(typeof new Date()) //object typeof 方法使用非常方便，但是要注意使用场景，不适合用来判断引用类型的数据 补充：symbol类型的变量一般用来作为一个对象的key（键值），而不是像普通变量一样接受一个值。 二、利用intanceof方法 ​ 原理：判断一个构造函数的prototype属性指向的对象是否存在于检测对象的原型链上 1234567891011121314151617181920let a = new Date();console.log(a instanceof Object) // trueconsole.log(a instanceof Number) // falseconsole.log(a instanceof Date) // truelet f = new Function();console.log(f instanceof Object) // trueconsole.log(f instanceof Function) // trueconsole.log(f instanceof Number) // falsefunction Person()&#123;&#125;;let p = new Person();console.log(p instanceof Person); //truefunction Man()&#123;&#125;;Man.prototype = p; //man 以p位原型对象继承Person类let m = new Man();console.log(m instanceof Man); //trueconsole.log(m instanceof Person); //true: // 原因Person.prototype === m.__proto__.__proto__,即Person的原型对象出现在了m对象的原型链上 适用场景：判断一个引用类型的变量所属的类。 因为Object.prototype是顶级原型对象，出现在所有的对象的原型链上，所以所有的对象采用instanceof Object === ture 三、Object.prototype.toString.call(&#39;待检测对象&#39;)–推荐使用 ​ 原理：利用js的内部属性[[class]](官方定义：一个字符串值，表明了该对象的类型)，[[class]]属性的值可以用来判断一个原生对象属于哪种内置类型，注意：在ECMAScript规范中规定这个属性只能通过Object.prototype.toString方法获取. ​ 具体执行过程： 1. 获取对象的`[[class]]`属性的值 2. 得到一个&quot;[Object, 步骤一获取到的表达内置类型的字符串]&quot; 样式的字符串 3. 返回步骤2得到的字符串12345678let obj = &#123;&#125;console.log(obj.toString()) //\"[Object, Object]\" 的原因之所在let arr = []console.log(arr.toString()) //\"\" 因为在数组类的原型对象上重新定义了自己的toString方法，除了数组很多内置对象都重写了这个方法，以满足更多的功能let bool = trueconsole.log(bool.toString()) //\"true\" Boolean对象也重写了该方法，更多详情如下表 类型 行为描述 Array 将 Array 的每个元素转换为字符串，并将它们依次连接起来，两个元素之间用英文逗号作为分隔符进行拼接。 Boolean 如果布尔值是 true，则返回 “true”。否则返回 “false”。 Date 返回日期的文本表示。 Error 返回一个包含相关错误信息的字符串。 Function 返回如下格式的字符串，其中 functionname 是一个函数的名称，此函数的 toString 方法被调用： “function functionname() { [native code] }” Number 返回数值的字符串表示。还可返回以指定进制表示的字符串，请参考 Number.toString()。 String 返回 String 对象的值。 Object(默认) 返回 “[object ObjectName]”，其中 ObjectName 是对象类型的名称。 回到Object.prototype.toString.call()用来判断数据类型的方法入下 12345678910let arr = [];Object.prototype.toString.call(arr) // \"[Object, Array]\"let num = 123;Object.prototype.toString.call(num) // \"[Object, Number]\"let str = \"hello world\";Object.prototype.toString.call(str) // \"[Object, String]\"//其它类型也是如此 还可以对其返回值做进一步的优化： 123456function getType(arg)&#123; return Object.prototype.toString.call(arg).slice(8, -1)&#125;let arr = []console.log(getType(arr)) // Array :这样就很清楚直接了 总结 判断基本的数据类型如：Number，String，Boolean 直接使用typeof 判断引用类型的所属类：instanceof足以 比较全能的使用: Object.prototype.toString.call(&#39;待测对象&#39;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"new操作符到底干了什么.md","slug":"new操作符到底干了什么-md","date":"2020-06-23T12:25:34.000Z","updated":"2020-06-23T13:18:08.434Z","comments":true,"path":"2020/06/23/new操作符到底干了什么-md/","link":"","permalink":"http://yoursite.com/2020/06/23/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88-md/","excerpt":"","text":"代码实例 12345let Func = function () &#123; //.... &#125;;let func = new Func(); new 一共经历了四个阶段 创建一个空对象 1let obj = new Object(); 设置原型链 1obj.__proto__ = Func.prototype; 让 Func 中的 this 指向 obj, 并执行 Func 的函数体 1let result = Func.call(obj); 判断Func返回值的类型： 如果构造函数没有 return 或者 return 的是基本类型，则返回this；如果 return 一个引用类型，则返回这个引用类型。 123456789101112131415161718192021222324if(typeof result === 'object')&#123; func = result;&#125;else&#123; func = obj;&#125;//eg:function Func1(name)&#123; this.name = name&#125;function Func2(name)&#123; this.name = name return 'string or number or boolean'&#125;function Func3(name)&#123; this.name = name return new String('123')&#125;let func1 = new Func1('Tom'); // func1-&gt; Func1:&#123;name:'Tom'&#125;let func2 = new Func2('Jack'); // func2 -&gt; Func2:&#123;name:'Jack'&#125;let func3 = new Func3('Bob'); // func3 -&gt; String:&#123;0:'B',1:'o',2:'b'&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"移动端页面和pc端页面的区别","slug":"移动端页面和pc端页面的区别","date":"2020-06-11T14:19:44.000Z","updated":"2020-06-11T14:30:53.606Z","comments":true,"path":"2020/06/11/移动端页面和pc端页面的区别/","link":"","permalink":"http://yoursite.com/2020/06/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%92%8Cpc%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"本文转载自:一梦梦的个人博客 一、使用体验上 操作方式 PC端的操作方式与移动端已经有了明显的差别，PC端使用鼠标操作，操作包含滑动、左击、右击、双击操作，操作相对来说单一，交互效果相对较少，而对于手机端来说，包含手指操作点击、滑动、双击、双指放大、双指缩小、五指收缩和苹果最新的3Dtouch按压力度，除了手指操作外还可以配合传感器完成摇一摇、陀悬仪感应灯操作方式，操作方式更加的丰富，通过这些丰富的操作可设计不同新颖吸引人的交互互动设计。 屏幕尺寸 随着时间的推移，移动端的设备屏幕逐渐增大，但是你再大也是大不过PC电脑屏幕的，这是毋庸置疑的。PC端屏幕大，所以他的视觉范围更广，可设计的地方更多，设计性更强，相对来说容错度更高一些有一些小的纰漏不容易被发现。移动端设备相对来说屏幕较小，操作局限性大，在设计上可用空间显得尤为珍贵，在小小的屏幕上使用粗大的手指操作也需要在设计中避免原件过小过近。 网络环境 当下不管是移动端还是PC端都离不开网络，PC端设备连接网络更加稳定，而移动端可能遇到信号问题导致网络环境不佳，出现网速差甚至断网的问题，这就需要产品经理在设计中充分考虑网络问题，更好的设计相应的解决方案。 传感器 移动端设备重磅武器来袭，完善的传感器是PC端设备望尘莫及的，压力、方向、重力、GPS、NFC、指纹识别、3Dtouch、陀螺仪等等等等，就是因为这些传感器的存在才使得我们的生活更加丰富多彩，有了他们你才能玩赛车游戏才能摇妹子才能统计每天走了多少步，产品在设计中巧妙地使用传感器能让产品添姿加彩。 使用场景与使用时间 这两块我们一起来说，因为PC端设备的使用场景多为在家或者学校公司等一些固定的场景，所以其使用时间偏向于持续化，在一个特定的时间段内持续使用，而移动端设备不受局限可以吃饭用、坐车用、拉屎用、无聊打发时间用、躺着用、坐着用、倒立着用都没人管你，随时随地想用就用，所以他的使用时间更加灵活，时间更加碎片化，所以在操作上更偏向于短时间内可完成的。 软件迭代时间以及更新频次 你有没有很久都没有更新你的PC软件了，但是你的手机软件确实永远保持着最新的状态，这就是他们两者的区别，对于移动端他的软件迭代时间较短，用户更新率较高而PC端软件迭代时间较长，除非出于需要用户一般不会主动更新软件，软件更新率低。 续航 除了笔记本PC端台式机只要有点他就从没有考虑过这个问题，移动端设备则需要考虑。 二、在功能设计上的区别你有没有在移动端看到过下拉菜单，有没有在PC端看到过滑动解锁，相同的功能在不同的设备上有其自己的展现形式，下面我们罗列一二，因为例子实在太多就不一一展开。 文字输入 在文字输入中，PC端一般使用文本框解决。而在移动端中因为手机屏幕尺寸以及UI风格的原因我们基本没有在手机上看到过PC端这样的展现形式，而是采用另起一页输入或者文字后直接输入方式，这就是各个平台根据自身特性的展现形式。 内容选择 在PC端中，一般使用下拉菜单或者是单选按钮形式完成内容选择。而在手机端由于手指的操作便捷性考虑一般不采用PC端的选择方式而是通过列表选择或者其他交互来完成。这样的设计点不胜枚举，就不一一展开了，还需要在日常生活工作中多多留意，切不可把PC端的设计模型照搬到移动端。","categories":[{"name":"others","slug":"others","permalink":"http://yoursite.com/categories/others/"}],"tags":[{"name":"others","slug":"others","permalink":"http://yoursite.com/tags/others/"}]},{"title":"浏览器渲染机制","slug":"浏览器渲染机制","date":"2020-05-29T10:37:10.000Z","updated":"2020-05-29T14:23:13.561Z","comments":true,"path":"2020/05/29/浏览器渲染机制/","link":"","permalink":"http://yoursite.com/2020/05/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一、什么是 DOCTYPE 及作用 DOCTYPE标签是一种标准通用标记语言的文档类型声明，它的目的是要告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。 DTD：document type definition，文档类型定义，是一系列的语法规则。会告诉浏览器以何种协议来解析文档，例如XML和HTML。 对于前端来说作用就是告诉浏览器以何种DTD，以什么标准来解析我们的文档也就是我们的html文件。 常见的 DOCTYPE HTML 5 &lt;!DOCTYPE html&gt; ，这是目前最主要的。 HTML 4.01 Strict 4.01版本的严格模式DTD，包含所有的HTML元素和属性，但是不包括展示性和已经弃用的元素 （比如 font）。这种模式下使用已经废弃过的元素，浏览器会报错。 1&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt; HTML 4.01 Transitional 4.01版本的传统模式DTD，包含所有的HTML元素和属性，包括展示性和已经弃用的元素 （比如 font）。 1&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt; 二、浏览器渲染过程 HTML 解释器解析 HTML 文件生成对应的DOM树，这也就是我们平常用js操作的DOM。同时CSS解释器解析CSS文件，生成相应的样式规则。 DOM Tree 和 Style Rules 经过结合生成渲染树，浏览器通过 Layout 计算渲染树中的每一个元素的渲染位置。 得出每一个元素的渲染位置以后，就开始绘制，然后显示。 三、Reflow（重排） DOM结构中的各个元素都有自己的盒子，这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程我们称之为reflow。 触发Reflow的条件: 增加，删除，修改DOM节点时，会导致Reflow或Repaint。 移动DOM的位置时，或者在元素上添加动画。 修改CSS样式时。 当Resize窗口的时候（移动端没有这个问题），或者是滚动页面的时候。 修改网页的默认字体时（不要轻易修改网页的默认字体）。 四、Repaint（重绘） 当各种盒子的位置，大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为repaint。 触发Repaint的条件: DOM改动 CSS改动 ps：总的来说导致repaint的原因就是上述两点，但具体的原因有非常多，总之页面出现了变化，肯定就导致了repaint。 频繁的 Repaint 会影响整个网页的性能和流畅度。 例如动态添加一百个div，那么正常情况下就会不断的repaint，为了减轻这种影响我们可以使用 document.createDocumentFragment()的方式将所有要添加的元素放入fragment片段中，最后统一插入document，这样就只会渲染一次。 12345678let root = document.querySelector('dom元素');let fragment = document.createDocumentFragment();for(let i = 0; i &lt; 100; i++)&#123; let div = document.createElement('div'); div.innerHTML = '我是第' + i + '个div'; fragment.appendChild(div);&#125;root.appendChild(fragment);","categories":[{"name":"html","slug":"html","permalink":"http://yoursite.com/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"事件委托","slug":"事件委托","date":"2020-05-26T13:26:59.000Z","updated":"2020-05-27T09:47:46.392Z","comments":true,"path":"2020/05/26/事件委托/","link":"","permalink":"http://yoursite.com/2020/05/26/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"事件委托是开发中会经常用到的一种事件优化方式，可以有效的减少代码量，减少内存的占用。 场景：例如一个无序列表ul拥有多个子元素li，每个li点击过后要执行的事件响应函数是不一样的，普通做法就是一个一个绑定事件，如下： 123456789101112131415161718192021222324252627282930313233&lt;style&gt; ul&#123; list-style:none; &#125; ul li&#123; width:100px; height:30px; float:left; background-color:thitle; margin-left:10px; &#125;&lt;/style&gt;&lt;ul&gt; &lt;li id=\"a\"&gt;&lt;/li&gt; &lt;li id=\"b\"&gt;&lt;/li&gt; &lt;li id=\"c\"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector(\"ul\"); let li_a = document.querySelector(\"#a\"); let li_b = document.querySelector(\"#b\"); let li_c = document.querySelector(\"#c\"); li_a.addEventListener('click',function()&#123; ... &#125;) li_b.addEventListener('click',function()&#123; .... &#125;) ....&lt;/script&gt; 上面就是普通写法，可以看出来代码相当的重复啰嗦，此时采用事件委托的方式，将点击事件直接绑定到父元素身上，再通过判断具体点击的是哪一个子元素，可以提高效率，并且减轻代码量。这里需要用到event.target属性，event.target详情参见&gt;&gt; 12345678910111213// html 部分和上面一样，省略let ul = document.querySelector(\"ul\");ul.addEventListener('click',function()&#123; if(event.target)&#123; if(event.target.id == \"a\")&#123; // do li_a的事件处理函数； &#125;else if(event.target.id == \"b\")&#123; // do li_b的事件处理函数 &#125;else&#123; // .... &#125; &#125; &#125;) 这样可有可以有效的减少事件的绑定，可以提高js代码的执行效率。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"DOM","slug":"JavaScript/DOM","permalink":"http://yoursite.com/categories/JavaScript/DOM/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"DOM事件","slug":"DOM事件","date":"2020-05-26T11:04:01.000Z","updated":"2020-05-26T14:08:23.375Z","comments":true,"path":"2020/05/26/DOM事件/","link":"","permalink":"http://yoursite.com/2020/05/26/DOM%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"DOM事件的级别 DOM0 element.onclick = function(){} DOM2 element.addEventListener(&#39;click&#39;,function(){},false) DOM3 element.addEventListener(&#39;keyup&#39;,function(){},false) DOM3 和 DOM2 相比只是添加了更多的事件类型，这里没有DOM1是因为DOM1没有实质性的内容。 DOM事件模型 事件模型有两个部分，捕获和冒泡。 1.何为DOMDOM是“Document Object Model”的缩写，中文译为“文档对象模型”。它是一种跨平台、跨语言的编程接口，将HTML，XHTML，XML文档映射成树形结构，树的每一个节点都是一个对象。正因如此，面向对象的编程语言（如javascript）可以通过DOM对HTML，XHTML，XML文档进行操作。对于HTML文档来说，它的根结点为document对象，HTML元素为element对象，HTML元素的属性为attr对象。 2.何为DOM事件及如何对其作出响应在浏览网页时，我们常常需要页面对用户的操作作出响应，比如点击“阅读全文”后我们期望页面展示被折叠的文本，按下回车键后浏览器提交已填好的表单。用户的各种操作都是“事件”。事件都是在对象上发生的，可能是DOM对象、BOM对象，等等。事件发生后，对象可能会作出响应，也有可能“无动于衷”。我们希望DOM元素对事件作出响应，一般而言有两种方法：i.事件属性事件属性是一种特殊的属性，它的值规定了对应事件发生时需要执行的javascript脚本。例： 1&lt;button onclick=\"console.log('button clicked!')\"&gt;&lt;/button&gt; 上面为button标签添加了事件属性onclick，其值为”console.log(‘button clicked!’)”，它规定了当元素被鼠标点击时，控制台输出’button clicked’。ii.addEventListener()方法EventTarget.addEventListener()方法将指定的监听器注册到EventTarget上，当该对象触发指定的事件时，指定的回调函数就会被执行。EventTarget可以是element对象,document对象或者任何其他支持事件的对象。例： 1234567&lt;!--html文件中--&gt;&lt;button id='mybutton'&gt;&lt;/button&gt;&lt;script&gt; var mybutton=document.getElementById('mybutton'); mybutton.addEventListener('click',function(e)&#123;console.log('button clicked!');&#125;);&lt;/script&gt; 上例为button元素注册了click事件的监听器，并规定事件时触发控制台输出’button clicked’。 3.DOM事件模型在讲解DOM事件模型前，再用一个例子作为引入。请看下面的html文件： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;DOM Event Model&lt;/title&gt; &lt;style&gt; div&#123;position: absolute;&#125; #outer&#123; top: 100px; left: 100px; width: 600px; height: 400px; background-color: #aff; &#125; #inner1,#inner2&#123; top: 50px; width: 200px; height: 300px; background-color: #f9a; &#125; #inner1&#123;left: 50px;&#125; #inner2&#123;left: 350px;&#125; #core&#123; left: 50px; top: 50px; width: 100px; height: 150px; background-color: #f50; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='outer' onclick=\"console.log(this.id)\"&gt; &lt;div id='inner1' onclick=\"console.log(this.id)\"&gt;&lt;/div&gt; &lt;div id='inner2' onclick=\"console.log(this.id)\"&gt; &lt;div id='core' onclick=\"console.log(this.id)\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里为id分别为outer,inner1,inner2,core的4个元素定义了事件属性，元素被点击后将在控制台输出它的id。现在问题来了：如果我点击core元素，控制台将会输出什么？点击core元素时，由于core元素包含在inner2元素里，inner2元素同样被点击了;同理，inner2元素包含在outer元素里，那么outer元素也被点击了。这种情况下哪一个元素的click事件将会被触发,或者说三者都被触发？如果说三者都被触发，那么又是以怎样的顺序被触发？我在火狐浏览器做了一次实验，控制台输出结果如下： 123coreinner2outer 也就是说，三者的事件都被触发了，且是“由内向外”触发的。下面我们再做一个有趣的实验：我们将上面的html文件再做一个小小的改动，将core元素的样式 1left: 50px; 改为 1left: -250px; 此时观察页面我们会发现，尽量core是inner2的子节点，但由于我们定义了“怪异”的样式，它跑到了inner1里面。现在我们再次用鼠标点击core，观察控制台的输出： 123coreinner2outer 和刚才的结果一模一样！尽管表面上inner1似乎被点击了，但它的click事件并没有触发;反而是看似未被点击的inner2元素的click事件被触发了。仿佛core元素的click事件被触发后，click事件一层一层向上“传播”给了父节点。为了解释刚才的实验结果，是时候开始讲解DOM事件模型了。当一个事件发生时，事件会在DOM树中进行传播。传播分为两个阶段： 捕获阶段在此阶段，事件从根结点（即document结点）开始向下传播，直到事件源所在元素。 冒泡阶段在此阶段，事件从事件源开始向上传播，直到根结点。 拿刚才的例子来说，事件传播的顺序为：document捕获-&gt;html捕获-&gt;body捕获-&gt;outer捕获-&gt;inner2捕获-&gt;core捕获-&gt;core冒泡-&gt;inner2冒泡-&gt;outer冒泡-&gt;html冒泡-&gt;document冒泡 对于事件属性，默认在冒泡阶段触发事件。如果用addEventListener()方法注册监听器，则可以指定在捕获阶段还是冒泡阶段触发事件：如果最后一个参数为false（默认值），则在冒泡阶段触发事件;如果为true，则在捕获阶段触发事件。 一般来说，我们推荐采用addEventListener()方法来注册监听器，而尽量不用事件属性。因为事件属性不利于行为与结构的分离，使代码难以维护。 DOM事件流一个完整的事件流包含三个阶段：捕获阶段（Capturing Phase）、事件处理阶段（Target Phase）、事件冒泡阶段（Bubbling Phase）。 从用户触发元素到浏览器执行响应事件这整个过程，就是事件流。 DOM事件捕获的具体流程见上图 Capturing Phase 阶段。 Event对象的常见应用 event.preventDefault() 阻止事件的默认行为，例如&lt;a&gt;&lt;/a&gt;标签的默认点击行为是跳转到新的页面，使用event.preventDefault()可以阻止这种跳转行为。 1234567&lt;a id=\"target\" href=\"www.baidu.com\"&gt;跳转到百度&lt;/a&gt;&lt;script&gt; let target = document.querySelector(\"#target\"); target.addEventListener(function(event)&#123; event.preventDefault(); //阻止跳转行为 &#125;)&lt;/script&gt; event.stopPropagation() 阻止冒泡行为：点击子元素时不会出发父元素的点击事件。 event.stopImmediatePropagation() 当一个DOM元素绑定了多个响应事件后，可以通过此方法阻止指定响应事件的执行。 event.currentTarget 就是指注册事件时所指向的元素。与event.target的区别，举例说明： 父级元素绑定了一个点击事件，在父级元素里面还有一个子元素，点击子元素肯定是会触发父元素的点击事件的，此时event.currentTarget就是父元素而eevent.target则是子元素。 具体的说就是event.currentTarget是注册事件时所指向的元素，而event.target是响应事件的最小子元素，也就是最深层级的触发事件的元素。这也是事件委托的原理。 12345678910111213141516171819202122232425&lt;style&gt; .parent&#123; width: 200px; height: 200px; background-color: thistle; &#125; .child&#123; width: 100px; height: 100px; background-color: skyblue; &#125;&lt;/style&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; let par = document.querySelector(\".parent\"); par.addEventListener('click',function()&#123; console.log('currentTarget', event.currentTarget); console.log('target',event.target); &#125;) &lt;/script&gt; 执行结果如下图所示： event.target 事件委托时用到的最多，当一个父级元素下面的子元素非常多，并且子元素都有各自的点击事件，普通做法就是一个一个添加响应事件，这种做法并不是理想的做法，浪费大量的内存，以及过多的事件注册会导致用户体验很差。 此时我们就可以采用事件委托的方式，将所有子元素的事件都绑定在父级元素上，然后通过event.target判断具体是点击的哪一个子元素，然后执行相应的事件处理函数即可。 事件委托详情参见&gt;&gt; 自定义事件12345678910// 自定义一个Event对象let eve = new Event('custome');// 绑定自定义事件dom.addEventListener('custome',function()&#123; console.log('custome');&#125;)// 执行自定义事件dom.dispatchEvent(eve);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"HTML","slug":"JavaScript/HTML","permalink":"http://yoursite.com/categories/JavaScript/HTML/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"css盒模型","slug":"css盒模型","date":"2020-05-25T01:51:26.000Z","updated":"2020-05-25T13:43:57.117Z","comments":true,"path":"2020/05/25/css盒模型/","link":"","permalink":"http://yoursite.com/2020/05/25/css%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"标准盒模型：FireFox、Chrome等标准浏览器默认盒模型，元素内容的宽高即元素宽高，不包括元素的内边距、外边距和边框。 IE盒模型: IE浏览器（IE9以下版本）的盒模型，元素宽高等于元素内容宽高+元素内边距宽高+元素边框的粗细。 首先要提一点：元素的大小不是指元素的宽高，只有先了解这一点才能正确理解盒模型，元素大小永远都是content + padding + border + margin，但是元素宽高就不是固定的了。 先来一张维基百科里面盒模型的图片： 如上图所示，一个元素一共分为 content、padding、border、margin 四个部分。 标准盒模型的宽 = 内容的宽（即上图的width）; 标准盒模型的高 = 内容的高（即上图的height）； IE盒模型的宽 = 内容的宽 + 左内边距 + 右内边距 + 左边框的宽度 + 右边框的宽度； 对应上图：content-width + padding-left + padding-right + border-left + border-right IE盒模型的高 = 内容的高 + 顶部内边距 + 底部内边距 + 顶部边框的高度 + 底部边框的高度； 对应上图：content-height + padding-top + padding-bottom + border-top + border-bottom box-sizing属性目前的标准浏览器渲染引擎都是使用标准盒子模型规则解析渲染元素，但是我们可以通过box-sizing属性手动指定浏览器的解析渲染方式。 值 描述 content-box 标准盒子模型。元素的宽高等于元素内容的宽高。元素的内边距，边框不参与到元素宽高的计算中。 border-box IE盒子模型。元素的宽高等于元素内容的宽/高+左右内边距的宽/高+边框的宽/高。 inherit 从父元素继承box-sizing属性的值。","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"layout","slug":"css/layout","permalink":"http://yoursite.com/categories/css/layout/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"javascript获取元素的宽高的四种方式","slug":"javascript获取元素的宽高的四种方式","date":"2020-05-24T09:48:32.000Z","updated":"2020-05-24T10:32:15.874Z","comments":true,"path":"2020/05/24/javascript获取元素的宽高的四种方式/","link":"","permalink":"http://yoursite.com/2020/05/24/javascript%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%BD%E9%AB%98%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"通过 javascript 获取元素的宽高是经常使用的，在此总结一些常见的方法，以及各个方法的区别，和适用场景。 一、dom.style.width/height通过 DOM 元素的 style 属性可以获取到元素的内联样式，如果元素的宽高是内联样式规定的可以采用这个方法。如果元素的宽高不是由内联样式指定，此方法无效。 1234567&lt;div id=\"targt\" style=\"width:100px;height:100px;background-color:thistle\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\"); console.log(dom.style.width); // 100px&lt;/script&gt; PS:此方法只能获取到元素的内联样式指定的宽高，如果是行内样式或者外联样式是获取不到的。 二、dom.currentStyle.width/height获取的是元素经过浏览器渲染以后的及时宽高，比较第一种更全面不局限于内联样式。但是此方法只对IE浏览器有效。 12345678910111213141516&lt;style&gt; #target&#123; width:100px; height:100px; background-color: thistle; &#125;&lt;/style&gt;&lt;div id=\"target\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\") console.log(dom.currentStyle.width); // IE浏览器下: 100px&lt;/script&gt; 三、window.getComputedStyle(dom).width/height这个原理跟第二种一样，是获取元素渲染以后的及时宽高，此方法适用的是标准浏览器Firefox、chrome等。 1234567891011121314151617&lt;style&gt; #target&#123; width:100px; height:100px; background-color: thistle; &#125;&lt;/style&gt;&lt;div id=\"target\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\") let width = window.getComputedStyle(dom).width; console.log(width); // 标准浏览器下: 100px;&lt;/script&gt; 四、dom.getBoundingClientRect().width/heightgetBoundingClientRect()这个api其实本事不是专门为了获取元素宽高而使用的，它主要是获取浏览器及时运行完以后一个dom元素的绝对位置信息，但是包含了元素宽高。返回了四个主要内容top、left、width、height。 1234567891011121314151617&lt;style&gt; #target&#123; width:100px; height:100px; background-color: thistle; &#125;&lt;/style&gt;&lt;div id=\"target\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\") let width = dom.getBoundingClientRect().width; console.log(width); // 100; 注意它只返回数值 100 而不是完整的 100px;&lt;/script&gt; getBoundingClientRect()完整返回值如下图所示：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"float布局","slug":"float布局","date":"2020-05-23T02:08:51.000Z","updated":"2020-05-23T08:58:56.449Z","comments":true,"path":"2020/05/23/float布局/","link":"","permalink":"http://yoursite.com/2020/05/23/float%E5%B8%83%E5%B1%80/","excerpt":"","text":"float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。 PS:假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 常见的取值 值 描述 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素正常显示。 inherit 从父元素继承float属性的值。 浮动原理设置了浮动属性的元素会脱离正常的文档流，相对于其它正常的元素浮动起来。浮动的参照边界是父级元素的边界或者是其它浮动元素的边界。如下图所示。 浮动的影响 不会影响未浮动的块级元素布局，但会影响内联元素的布局。 12345678910111213141516171819202122232425262728&lt;section&gt; &lt;style&gt; #container-one&#123; height: 200px; &#125; #container-one div&#123; width: 100px; height: 100px; &#125; #container-one span&#123; background-color: deepskyblue; &#125; .item-block&#123; background-color: thistle; &#125; .item-float&#123; background-color: wheat; &#125; .item-float-left&#123; float: left; &#125; &lt;/style&gt; &lt;article id=\"container-one\"&gt; &lt;div class=\"item-block\"&gt;&lt;/div&gt; &lt;span&gt;这是一个行内元素&lt;/span&gt; &lt;div class=\"item-float item-float-left\"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; 浮动后的元素可以设置宽度和高度，意味着内联元素浮动以后会变成 inline-block 元素 123456789101112131415161718192021222324&lt;section&gt; &lt;style&gt; #container-two&#123; width: 500px; height: 100px; background-color: darkcyan; &#125; #container-two span&#123; width: 200px; height: 100px; background-color: deepskyblue; &#125; #container-two .float&#123; float: left; background-color: wheat; &#125; &lt;/style&gt; &lt;article id=\"container-two\"&gt; &lt;span&gt;普通内联元素,无法设置宽高&lt;/span&gt; &lt;span class=\"float\"&gt;浮动后的内联元素，可以设置宽高&lt;/span&gt; &lt;/article&gt;&lt;/section&gt; 可能导致父元素高度坍塌 前面的示例都是对父元素设置了一个固定高度，如果不设置这个高度，正常来说父元素的高度将由子元素的高度撑开，但是浮动后的子元素是脱离了正常的文档流的，这种情况下是不会为父元素提供可使用的高度的。 123456789101112131415161718192021222324252627&lt;section&gt; &lt;style&gt; #container-three&#123; width: 500px; background-color: darkcyan; &#125; #container-three .float&#123; width: 100px; height: 100px; &#125; #container-three .float-left&#123; float: left; background-color: thistle; &#125; #container-three .float-right&#123; float: right; background-color: wheat; &#125; &lt;/style&gt; &lt;article id=\"container-three\"&gt; &lt;div class=\"float float-left\"&gt;左浮动子元素&lt;/div&gt; &lt;div class=\"float float-right\"&gt;右浮动子元素&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 如上图所示，浮动的子元素还是可以找到正确的参照边界（父元素的左右边框），但是通过审查元素会发现父级元素 &lt;article id=&quot;contaiiner&gt;&lt;/article&gt;&quot; 的高度是0。这就是元素浮动导致的父级元素高度坍塌现象。 闭合浮动 清除浮动和闭合浮动的区别： 清除浮动是指的CSS中的属性: clear: left|right|both|none; 闭合浮动是指的是，通过一定方法，减少或消除在布局过程中由于使用浮动属性带来的问题，例如上面提到的父级元素高度崩塌等问题。 闭合浮动常用的几种方式： 1、在浮动元素末尾添加一个空 div 设置其 clear 属性值为 both，例如 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; 2、父级元素定义 overflow:hidden 3、对父级元素也使用浮动，就是说让所有元素都浮动起来，这种方法只建议用于理论，实际操作这种方式不太显示。 4、对父级元素设置伪元素，即 ：after 1234567.class-name:after&#123; display: block; height: 0; clear: both; visibility: hidden; content: \"\"&#125; 如上图所示：闭合浮动后父级元素的高度出来了，这样即可解决高度崩塌的问题了。","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"layout","slug":"css/layout","permalink":"http://yoursite.com/categories/css/layout/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"配置npm安装全局模块时的路径","slug":"配置npm安装全局模块时的路径","date":"2020-05-22T04:09:35.000Z","updated":"2020-05-22T05:46:40.332Z","comments":true,"path":"2020/05/22/配置npm安装全局模块时的路径/","link":"","permalink":"http://yoursite.com/2020/05/22/%E9%85%8D%E7%BD%AEnpm%E5%AE%89%E8%A3%85%E5%85%A8%E5%B1%80%E6%A8%A1%E5%9D%97%E6%97%B6%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"配置原因: 在执行 npm install &#39;包名&#39; -g 命令全局安装的时候，会默认将模块安装在 C:\\Users\\用户名\\AppData\\Roaming路径下的npm和npm_cache 中，不方便管理并且占用 C 盘空间。 解决方案：配置自定义的全局模块安装目录。 手动创建两个文件夹 node_global 和 node_cache 。 如果你的 Node.js 没有安装在 C 盘，你可以直接在 Node.js 的安装目录下创建这两个文件。 如果你的 Node.js 是安装在 C 盘的，那么不建议你直接在其安装目录下创建，因为这样做意义不大，包文件还是存放在 C 盘。这种情况你可以在 C 盘以外你认为比较好管理的地方创建 node_global 和 node_cache 这两个目录。 上图的npm-install-package 也是我手动创建的。总之哪里好管理你就先建在那里。 在 cmd 命令行下执行如下配置命令： 123npm config set prefix \"D:\\npm-install-package\\node_global\"npm config set cache \"D:\\npm-install-package\\node_cache\" 执行完毕后，需要去配置环境变量： 环境变量 – 系统变量：新建一个变量 NODE_PATH ，值为 D:\\npm-install-package\\node_global\\node_modules，如下图所示： 环境变量 – 用户变量：编辑用户变量里面的Path，将原来的 npm 路径 (“C:\\Users\\用户名\\AppData\\Roaming\\npm”) 改为 D:\\npm-install-package\\node_global 如下图所示： 配置已经完成，可以全局安装一个包测试一下。 cmd 下执行 npm install webpack -g 全局安装 webpack 如下图所示： 安装完毕后查看我们的node_cache 和 node_global 文件夹，如下图所示： 最后 cmd 任意目录下输入 webpack -v 检查是否安装成功，如下图所示： 可能遇到的问题 首先是 cnpm 的问题：有些兄弟之前为了装包快是自己配置了淘宝镜像的，但是当我们配置完了上面的内容会发现 cnpm 用不了了 cnpm 不是系统内部或外部命令。这是由于我们更改了环境变量导致的，因为原来的 cnpm 是装在了 “C:\\Users\\用户名\\AppData\\Roaming\\npm” 里的，后来改变了该路径，所以系统找不到我们的 cnpm 很正常。 此时你只需要重新执行 npm install cnpm -g --registry=https://registry.npm.taobao.org 就行了。执行以后在我们的 node_global 下可以看见如下图所示： 并且可以在 node_global\\node_modules 下看见我们安装的包，如下图所示： 同理之前其它的包有可能也用不了了，只需重新安装就好。","categories":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/categories/npm/"},{"name":"Node.js","slug":"npm/Node-js","permalink":"http://yoursite.com/categories/npm/Node-js/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"ES6（一）-let和const命令","slug":"ES6（一）-let和const命令","date":"2020-05-16T14:34:04.000Z","updated":"2020-05-17T02:30:47.953Z","comments":true,"path":"2020/05/16/ES6（一）-let和const命令/","link":"","permalink":"http://yoursite.com/2020/05/16/ES6%EF%BC%88%E4%B8%80%EF%BC%89-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1. let 命令 ES6 新增 let 命令，用于声明变量。用来解决 var 命令带来的弊端，是新一代的标准。 let 命令与 var 命令的区别： 只作用于 let 命令所在的块级作用域。 1234567&#123; var a = 1; let b = 2;&#125;a // 1b // ReferenceError: a is not defined; 上面代码中 {} 中为一个单独的块级作用域，在这个作用域中用 var 声明的变量，在该作用域以外还是可以被正常访问，而在该作用域中用 let 命令声明的变量，在该作用域外部引用会报错。 不存在变量提升。 变量提升：即变量在未声明之前就可以使用，值为undefined。这种现象就是变量提升。 12345console.log(a); // undefinedvar a = 1;console.log(b); // ReferenceErrorlet b = 2; 上面代码中使用 var 命令声明的变量，在声明之前已经可以调用，只不过输出的值为 undefined 。而使用 let 命令声明的变量，在声明之前不可以调用，会报错。 js 预编译阶段：此阶段进行变量和函数的声明（特指声明式函数），但是不对变量进行赋值，变量的默认值为 undefined 。这也是变量提示的原因所在 js 代码执行阶段：此阶段对变量进行赋值和函数的调用。 变量提升的实质：js 在预编译阶段将所有的声明提到代码最前面，此时内存中有一个存放 undefined 的地方，将这些声明的变量或函数全部指向该内存地址。因为变量的实质就是一个内存地址，用来指向某个我们赋值给它的数据。 上面是 js 的执行顺序，使用 let 命令声明的变量，在预编译阶段 js 解析引擎是不会对其进行变量提升操作，不会将他提到代码最前面，所以用 let 命令声明的变量，在 let 前面出现时它的值并不是 undefined而是一段解析引擎不认识的一个非法变量，这个变量不是一个有效的内存地址，所以解析引擎会直接抛出一个错误。 暂时性死区。 只要块级作用域内存在 let 命令，它所声明的变量就“绑定”(binding)这个区域，不在受外部影响。 在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。在语法上，成为“暂时性死区”（temporal dead zone, 简称 TDZ）。 123456var a = '123';if(true)&#123; a = '321'; // ReferenceError let a;&#125; 从上述代码可以看出，即使在 if 代码块前面声明了变量 a ，但在 if 代码块内部由于 let 命令的存在，所以代码块内部的变量 a 只认内部的 let 命令，只能在 let 命令之后使用，否则会报错，这就是暂时性死区。 不允许重复声明。 当使用 var 命令去声明变量时，可以重复声明，在语法这没有任何问题，解析引擎会将后面的声明覆盖掉前面的声明。但是 let 命令是在同一个块级作用域内是不允许重复声明的，var 也不行。 1234function()&#123; let a = 123; var a = 123;&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript的call、apply、bind函数的用法和区别","slug":"JavaScript的call、apply、bind函数的用法和区别","date":"2020-05-16T05:07:33.000Z","updated":"2020-05-16T06:10:34.145Z","comments":true,"path":"2020/05/16/JavaScript的call、apply、bind函数的用法和区别/","link":"","permalink":"http://yoursite.com/2020/05/16/JavaScript%E7%9A%84call%E3%80%81apply%E3%80%81bind%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、用法 这三个方法都是 JavaScript 函数原型链上的方法，每个函数都会自动继承这三个方法。 总的来说三者都是用来改变this指向的，可以实现在一个对象的成员函数调用其它对象的成员函数或者成员变量。 123456789101112131415161718let jack = &#123; name:'jack', age:'23'&#125;let tom = &#123; name:'tom', age:'20', printMessage: function()&#123; console.log('This is ' + this.name + ',he is ' + this.age) &#125;&#125;tom.printMessage.call(jack); // 结果：This is jack,he is 23.tom.printMessage.apply(jack); // 结果：This is jack,he is 23.tom.printMessage.bind(jack)(); // 结果：This is jack,he is 23.// 可以看见printMessage内部的this指向被改变，不在指向调用它的对象tom，而是指向了call、apply、bind传入的参数：对象jack。 二、区别 这三个方法，在用途上没有什么区别，关键是在用法上存在区别。体现在他们三者的参数列表和返回值。 12345678910111213141516171819202122232425let jack = &#123; name: 'jack', age: '23'&#125;let tom = &#123; name: 'tom', age: '20', printMessage: function(from,to)&#123; console.log('This is ' + this.name + ',he is ' + this.age + 'from' + from + ' to ' + to + '.') &#125;&#125;// call方法，接受多个参数，第一个参数为执行函数的this值，其余参数将会按顺序赋值给执行函数的参数列表tom.printMessage.call(jack,'Beijin','Shanghai');// This is jack,he is 23 from Beijin to Shanghai/* apply方法，接受两个参数，第一个参数为执行函数的this值，第二个参数是一个数组，数组元素将会按顺序赋值给执行函数的参数列表 */tom.printMessage.apply(jack,['Beijin','Shanghai']);// This is jack,he is 23 from Beijin to Shanghai/* bind方法，接受参数形式与call方法一致，但是返回的是一个新的函数，必须要手动调用一次才会执行。*/tom.printMessage.bind(jack,'Beijin','Shanghai')();// This is jack,he is 23 from Beijin to Shanghai","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript中i++和++i的区别","slug":"JavaScript中i-和-i的区别","date":"2020-05-11T10:47:21.000Z","updated":"2020-05-11T13:00:59.496Z","comments":true,"path":"2020/05/11/JavaScript中i-和-i的区别/","link":"","permalink":"http://yoursite.com/2020/05/11/JavaScript%E4%B8%ADi-%E5%92%8C-i%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、++ i 和 i ++简单介绍++ 运算符又称自增运算符，功能为将操作数自加 1。 ++ i 被称为前加加，++ 后面的变量执行自加操作，执行顺序为：先执行变量的自加操作，再引用变量的值。 i ++ 被称为后加加，++ 前面的变量执行自加操作，执行顺序为：先引用变量的值，在执行自加操作。 在实际代码中，如果加加语句是一个独立的语句，那么两者是完全相同的。比如： 123a ++; /*完全等价于*/ ++ a;// orfor(let i = 0; i &lt; 10; i ++)&#123;...&#125; /*两者是完全等价的*/ for(let i = 0; i &lt; 10 ; ++ i)&#123;...&#125; 上面两个示例 自增语句都是一个独立的语句，在这种情况下，++ i和i ++是完全等价的。 二、 ++ i 和 i ++ 使用时的区别当加加语句不是一个独立的语句，只是某一个语句的一部分，二者就有区别了。 i ++ 12345let i = 0;let j = i ++; //此时完整的语句为 let j = i ++;先执行变量赋值，再执行 ++ 操作先j = i = 0 后i = 1;let i = 0;while( i ++ &lt; 10); // 此时i是从0开始第一次比较，先判断 i &lt; 10,然后变量i再执行加加操作; ++ i 12345let i = 0;let j = ++ i; //此时完整的语句为 let j = ++ i;先执行 ++ 操作，再赋值变量：先i = 1后j = i = 1;let i = 0;while( ++ i &lt; 10); // 此时i是从1开始第一次比较,变量i先执行加加操作，再判断 i &lt; 10;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"operator","slug":"JavaScript/operator","permalink":"http://yoursite.com/categories/JavaScript/operator/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"operator","slug":"operator","permalink":"http://yoursite.com/tags/operator/"}]},{"title":"Vue-cli@3中使用bootstrap","slug":"vue-import-bootstrap","date":"2020-05-07T16:38:49.000Z","updated":"2020-05-08T16:21:49.562Z","comments":true,"path":"2020/05/08/vue-import-bootstrap/","link":"","permalink":"http://yoursite.com/2020/05/08/vue-import-bootstrap/","excerpt":"","text":"Vue-cli@3创建的项目中如何使用Bootstrap一、安装所需包 Bootstrap 是基于 jQuery 开发的，所以先安装 jQuery。 1$ cnpm install jquery -s 安装 Popper.js, BootStrap 内部有些嵌套组件，是依靠 Popper.js 来实现定位的。非必须安装如果你的项目会用到 BootStrap 中的类似于 下拉列表这样的组件，建议先提前安装 popper.js,否则可能报错。关于popper.js的介绍以及具体介绍如下。 Popper.js是一款功能强大的JS定位引擎。 站在原型链顶端的男人的博客 1$ cnpm install popper.js -s 安装 BootStrap 包。 1$ cnpm install bootstrap@3 -s 二、配置main.js 全局引入 bootstrap 和 jquery 注意导入时，import $ from &#39;jquery&#39; 要写在最前面。否则可能报错 三、配置 vue.config.js 在 vue-cli@3搭建的 vue 项目默认是不没有该文件的，需要在 package.json 的同级目录下手动创建。具体代码如下： 如果一切顺利，便可以使用了。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Bootstrap","slug":"Vue/Bootstrap","permalink":"http://yoursite.com/categories/Vue/Bootstrap/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"others","slug":"others","permalink":"http://yoursite.com/categories/others/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/categories/html/"},{"name":"DOM","slug":"JavaScript/DOM","permalink":"http://yoursite.com/categories/JavaScript/DOM/"},{"name":"HTML","slug":"JavaScript/HTML","permalink":"http://yoursite.com/categories/JavaScript/HTML/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"layout","slug":"css/layout","permalink":"http://yoursite.com/categories/css/layout/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/categories/npm/"},{"name":"Node.js","slug":"npm/Node-js","permalink":"http://yoursite.com/categories/npm/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"},{"name":"operator","slug":"JavaScript/operator","permalink":"http://yoursite.com/categories/JavaScript/operator/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Bootstrap","slug":"Vue/Bootstrap","permalink":"http://yoursite.com/categories/Vue/Bootstrap/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"others","slug":"others","permalink":"http://yoursite.com/tags/others/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"operator","slug":"operator","permalink":"http://yoursite.com/tags/operator/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"}]}