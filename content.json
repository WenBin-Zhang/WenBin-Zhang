{"meta":{"title":"WenBin-Zhang","subtitle":"前端小白","description":"Runoob of web front end~","author":"WenBin-Zhang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-04T06:01:41.000Z","updated":"2020-05-04T06:11:18.655Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-04T04:06:47.000Z","updated":"2020-05-04T06:10:31.409Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-04T06:00:34.000Z","updated":"2020-05-04T06:11:10.983Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-05-04T02:55:50.638Z","updated":"2020-05-04T02:31:35.585Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"css盒模型","slug":"css盒模型","date":"2020-05-25T01:51:26.000Z","updated":"2020-05-25T13:43:57.117Z","comments":true,"path":"2020/05/25/css盒模型/","link":"","permalink":"http://yoursite.com/2020/05/25/css%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"标准盒模型：FireFox、Chrome等标准浏览器默认盒模型，元素内容的宽高即元素宽高，不包括元素的内边距、外边距和边框。 IE盒模型: IE浏览器（IE9以下版本）的盒模型，元素宽高等于元素内容宽高+元素内边距宽高+元素边框的粗细。 首先要提一点：元素的大小不是指元素的宽高，只有先了解这一点才能正确理解盒模型，元素大小永远都是content + padding + border + margin，但是元素宽高就不是固定的了。 先来一张维基百科里面盒模型的图片： 如上图所示，一个元素一共分为 content、padding、border、margin 四个部分。 标准盒模型的宽 = 内容的宽（即上图的width）; 标准盒模型的高 = 内容的高（即上图的height）； IE盒模型的宽 = 内容的宽 + 左内边距 + 右内边距 + 左边框的宽度 + 右边框的宽度； 对应上图：content-width + padding-left + padding-right + border-left + border-right IE盒模型的高 = 内容的高 + 顶部内边距 + 底部内边距 + 顶部边框的高度 + 底部边框的高度； 对应上图：content-height + padding-top + padding-bottom + border-top + border-bottom box-sizing属性目前的标准浏览器渲染引擎都是使用标准盒子模型规则解析渲染元素，但是我们可以通过box-sizing属性手动指定浏览器的解析渲染方式。 值 描述 content-box 标准盒子模型。元素的宽高等于元素内容的宽高。元素的内边距，边框不参与到元素宽高的计算中。 border-box IE盒子模型。元素的宽高等于元素内容的宽/高+左右内边距的宽/高+边框的宽/高。 inherit 从父元素继承box-sizing属性的值。","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"layout","slug":"css/layout","permalink":"http://yoursite.com/categories/css/layout/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"javascript获取元素的宽高的四种方式","slug":"javascript获取元素的宽高的四种方式","date":"2020-05-24T09:48:32.000Z","updated":"2020-05-24T10:32:15.874Z","comments":true,"path":"2020/05/24/javascript获取元素的宽高的四种方式/","link":"","permalink":"http://yoursite.com/2020/05/24/javascript%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E5%AE%BD%E9%AB%98%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"通过 javascript 获取元素的宽高是经常使用的，在此总结一些常见的方法，以及各个方法的区别，和适用场景。 一、dom.style.width/height通过 DOM 元素的 style 属性可以获取到元素的内联样式，如果元素的宽高是内联样式规定的可以采用这个方法。如果元素的宽高不是由内联样式指定，此方法无效。 1234567&lt;div id=\"targt\" style=\"width:100px;height:100px;background-color:thistle\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\"); console.log(dom.style.width); // 100px&lt;/script&gt; PS:此方法只能获取到元素的内联样式指定的宽高，如果是行内样式或者外联样式是获取不到的。 二、dom.currentStyle.width/height获取的是元素经过浏览器渲染以后的及时宽高，比较第一种更全面不局限于内联样式。但是此方法只对IE浏览器有效。 12345678910111213141516&lt;style&gt; #target&#123; width:100px; height:100px; background-color: thistle; &#125;&lt;/style&gt;&lt;div id=\"target\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\") console.log(dom.currentStyle.width); // IE浏览器下: 100px&lt;/script&gt; 三、window.getComputedStyle(dom).width/height这个原理跟第二种一样，是获取元素渲染以后的及时宽高，此方法适用的是标准浏览器Firefox、chrome等。 1234567891011121314151617&lt;style&gt; #target&#123; width:100px; height:100px; background-color: thistle; &#125;&lt;/style&gt;&lt;div id=\"target\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\") let width = window.getComputedStyle(dom).width; console.log(width); // 标准浏览器下: 100px;&lt;/script&gt; 四、dom.getBoundingClientRect().width/heightgetBoundingClientRect()这个api其实本事不是专门为了获取元素宽高而使用的，它主要是获取浏览器及时运行完以后一个dom元素的绝对位置信息，但是包含了元素宽高。返回了四个主要内容top、left、width、height。 1234567891011121314151617&lt;style&gt; #target&#123; width:100px; height:100px; background-color: thistle; &#125;&lt;/style&gt;&lt;div id=\"target\"&gt; &lt;/div&gt;&lt;script&gt; let dom = document.querySelector(\"#target\") let width = dom.getBoundingClientRect().width; console.log(width); // 100; 注意它只返回数值 100 而不是完整的 100px;&lt;/script&gt; getBoundingClientRect()完整返回值如下图所示：","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"float布局","slug":"float布局","date":"2020-05-23T02:08:51.000Z","updated":"2020-05-23T08:58:56.449Z","comments":true,"path":"2020/05/23/float布局/","link":"","permalink":"http://yoursite.com/2020/05/23/float%E5%B8%83%E5%B1%80/","excerpt":"","text":"float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。 PS:假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。 常见的取值 值 描述 left 元素向左浮动。 right 元素向右浮动。 none 默认值。元素正常显示。 inherit 从父元素继承float属性的值。 浮动原理设置了浮动属性的元素会脱离正常的文档流，相对于其它正常的元素浮动起来。浮动的参照边界是父级元素的边界或者是其它浮动元素的边界。如下图所示。 浮动的影响 不会影响未浮动的块级元素布局，但会影响内联元素的布局。 12345678910111213141516171819202122232425262728&lt;section&gt; &lt;style&gt; #container-one&#123; height: 200px; &#125; #container-one div&#123; width: 100px; height: 100px; &#125; #container-one span&#123; background-color: deepskyblue; &#125; .item-block&#123; background-color: thistle; &#125; .item-float&#123; background-color: wheat; &#125; .item-float-left&#123; float: left; &#125; &lt;/style&gt; &lt;article id=\"container-one\"&gt; &lt;div class=\"item-block\"&gt;&lt;/div&gt; &lt;span&gt;这是一个行内元素&lt;/span&gt; &lt;div class=\"item-float item-float-left\"&gt;&lt;/div&gt; &lt;/article&gt; &lt;/section&gt; 浮动后的元素可以设置宽度和高度，意味着内联元素浮动以后会变成 inline-block 元素 123456789101112131415161718192021222324&lt;section&gt; &lt;style&gt; #container-two&#123; width: 500px; height: 100px; background-color: darkcyan; &#125; #container-two span&#123; width: 200px; height: 100px; background-color: deepskyblue; &#125; #container-two .float&#123; float: left; background-color: wheat; &#125; &lt;/style&gt; &lt;article id=\"container-two\"&gt; &lt;span&gt;普通内联元素,无法设置宽高&lt;/span&gt; &lt;span class=\"float\"&gt;浮动后的内联元素，可以设置宽高&lt;/span&gt; &lt;/article&gt;&lt;/section&gt; 可能导致父元素高度坍塌 前面的示例都是对父元素设置了一个固定高度，如果不设置这个高度，正常来说父元素的高度将由子元素的高度撑开，但是浮动后的子元素是脱离了正常的文档流的，这种情况下是不会为父元素提供可使用的高度的。 123456789101112131415161718192021222324252627&lt;section&gt; &lt;style&gt; #container-three&#123; width: 500px; background-color: darkcyan; &#125; #container-three .float&#123; width: 100px; height: 100px; &#125; #container-three .float-left&#123; float: left; background-color: thistle; &#125; #container-three .float-right&#123; float: right; background-color: wheat; &#125; &lt;/style&gt; &lt;article id=\"container-three\"&gt; &lt;div class=\"float float-left\"&gt;左浮动子元素&lt;/div&gt; &lt;div class=\"float float-right\"&gt;右浮动子元素&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 如上图所示，浮动的子元素还是可以找到正确的参照边界（父元素的左右边框），但是通过审查元素会发现父级元素 &lt;article id=&quot;contaiiner&gt;&lt;/article&gt;&quot; 的高度是0。这就是元素浮动导致的父级元素高度坍塌现象。 闭合浮动 清除浮动和闭合浮动的区别： 清除浮动是指的CSS中的属性: clear: left|right|both|none; 闭合浮动是指的是，通过一定方法，减少或消除在布局过程中由于使用浮动属性带来的问题，例如上面提到的父级元素高度崩塌等问题。 闭合浮动常用的几种方式： 1、在浮动元素末尾添加一个空 div 设置其 clear 属性值为 both，例如 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; 2、父级元素定义 overflow:hidden 3、对父级元素也使用浮动，就是说让所有元素都浮动起来，这种方法只建议用于理论，实际操作这种方式不太显示。 4、对父级元素设置伪元素，即 ：after 1234567.class-name:after&#123; display: block; height: 0; clear: both; visibility: hidden; content: \"\"&#125; 如上图所示：闭合浮动后父级元素的高度出来了，这样即可解决高度崩塌的问题了。","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"layout","slug":"css/layout","permalink":"http://yoursite.com/categories/css/layout/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"}]},{"title":"配置npm安装全局模块时的路径","slug":"配置npm安装全局模块时的路径","date":"2020-05-22T04:09:35.000Z","updated":"2020-05-22T05:46:40.332Z","comments":true,"path":"2020/05/22/配置npm安装全局模块时的路径/","link":"","permalink":"http://yoursite.com/2020/05/22/%E9%85%8D%E7%BD%AEnpm%E5%AE%89%E8%A3%85%E5%85%A8%E5%B1%80%E6%A8%A1%E5%9D%97%E6%97%B6%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"配置原因: 在执行 npm install &#39;包名&#39; -g 命令全局安装的时候，会默认将模块安装在 C:\\Users\\用户名\\AppData\\Roaming路径下的npm和npm_cache 中，不方便管理并且占用 C 盘空间。 解决方案：配置自定义的全局模块安装目录。 手动创建两个文件夹 node_global 和 node_cache 。 如果你的 Node.js 没有安装在 C 盘，你可以直接在 Node.js 的安装目录下创建这两个文件。 如果你的 Node.js 是安装在 C 盘的，那么不建议你直接在其安装目录下创建，因为这样做意义不大，包文件还是存放在 C 盘。这种情况你可以在 C 盘以外你认为比较好管理的地方创建 node_global 和 node_cache 这两个目录。 上图的npm-install-package 也是我手动创建的。总之哪里好管理你就先建在那里。 在 cmd 命令行下执行如下配置命令： 123npm config set prefix \"D:\\npm-install-package\\node_global\"npm config set cache \"D:\\npm-install-package\\node_cache\" 执行完毕后，需要去配置环境变量： 环境变量 – 系统变量：新建一个变量 NODE_PATH ，值为 D:\\npm-install-package\\node_global\\node_modules，如下图所示： 环境变量 – 用户变量：编辑用户变量里面的Path，将原来的 npm 路径 (“C:\\Users\\用户名\\AppData\\Roaming\\npm”) 改为 D:\\npm-install-package\\node_global 如下图所示： 配置已经完成，可以全局安装一个包测试一下。 cmd 下执行 npm install webpack -g 全局安装 webpack 如下图所示： 安装完毕后查看我们的node_cache 和 node_global 文件夹，如下图所示： 最后 cmd 任意目录下输入 webpack -v 检查是否安装成功，如下图所示： 可能遇到的问题 首先是 cnpm 的问题：有些兄弟之前为了装包快是自己配置了淘宝镜像的，但是当我们配置完了上面的内容会发现 cnpm 用不了了 cnpm 不是系统内部或外部命令。这是由于我们更改了环境变量导致的，因为原来的 cnpm 是装在了 “C:\\Users\\用户名\\AppData\\Roaming\\npm” 里的，后来改变了该路径，所以系统找不到我们的 cnpm 很正常。 此时你只需要重新执行 npm install cnpm -g --registry=https://registry.npm.taobao.org 就行了。执行以后在我们的 node_global 下可以看见如下图所示： 并且可以在 node_global\\node_modules 下看见我们安装的包，如下图所示： 同理之前其它的包有可能也用不了了，只需重新安装就好。","categories":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/categories/npm/"},{"name":"Node.js","slug":"npm/Node-js","permalink":"http://yoursite.com/categories/npm/Node-js/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"ES6（一）-let和const命令","slug":"ES6（一）-let和const命令","date":"2020-05-16T14:34:04.000Z","updated":"2020-05-17T02:30:47.953Z","comments":true,"path":"2020/05/16/ES6（一）-let和const命令/","link":"","permalink":"http://yoursite.com/2020/05/16/ES6%EF%BC%88%E4%B8%80%EF%BC%89-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1. let 命令 ES6 新增 let 命令，用于声明变量。用来解决 var 命令带来的弊端，是新一代的标准。 let 命令与 var 命令的区别： 只作用于 let 命令所在的块级作用域。 1234567&#123; var a = 1; let b = 2;&#125;a // 1b // ReferenceError: a is not defined; 上面代码中 {} 中为一个单独的块级作用域，在这个作用域中用 var 声明的变量，在该作用域以外还是可以被正常访问，而在该作用域中用 let 命令声明的变量，在该作用域外部引用会报错。 不存在变量提升。 变量提升：即变量在未声明之前就可以使用，值为undefined。这种现象就是变量提升。 12345console.log(a); // undefinedvar a = 1;console.log(b); // ReferenceErrorlet b = 2; 上面代码中使用 var 命令声明的变量，在声明之前已经可以调用，只不过输出的值为 undefined 。而使用 let 命令声明的变量，在声明之前不可以调用，会报错。 js 预编译阶段：此阶段进行变量和函数的声明（特指声明式函数），但是不对变量进行赋值，变量的默认值为 undefined 。这也是变量提示的原因所在 js 代码执行阶段：此阶段对变量进行赋值和函数的调用。 变量提升的实质：js 在预编译阶段将所有的声明提到代码最前面，此时内存中有一个存放 undefined 的地方，将这些声明的变量或函数全部指向该内存地址。因为变量的实质就是一个内存地址，用来指向某个我们赋值给它的数据。 上面是 js 的执行顺序，使用 let 命令声明的变量，在预编译阶段 js 解析引擎是不会对其进行变量提升操作，不会将他提到代码最前面，所以用 let 命令声明的变量，在 let 前面出现时它的值并不是 undefined而是一段解析引擎不认识的一个非法变量，这个变量不是一个有效的内存地址，所以解析引擎会直接抛出一个错误。 暂时性死区。 只要块级作用域内存在 let 命令，它所声明的变量就“绑定”(binding)这个区域，不在受外部影响。 在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。在语法上，成为“暂时性死区”（temporal dead zone, 简称 TDZ）。 123456var a = '123';if(true)&#123; a = '321'; // ReferenceError let a;&#125; 从上述代码可以看出，即使在 if 代码块前面声明了变量 a ，但在 if 代码块内部由于 let 命令的存在，所以代码块内部的变量 a 只认内部的 let 命令，只能在 let 命令之后使用，否则会报错，这就是暂时性死区。 不允许重复声明。 当使用 var 命令去声明变量时，可以重复声明，在语法这没有任何问题，解析引擎会将后面的声明覆盖掉前面的声明。但是 let 命令是在同一个块级作用域内是不允许重复声明的，var 也不行。 1234function()&#123; let a = 123; var a = 123;&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript的call、apply、bind函数的用法和区别","slug":"JavaScript的call、apply、bind函数的用法和区别","date":"2020-05-16T05:07:33.000Z","updated":"2020-05-16T06:10:34.145Z","comments":true,"path":"2020/05/16/JavaScript的call、apply、bind函数的用法和区别/","link":"","permalink":"http://yoursite.com/2020/05/16/JavaScript%E7%9A%84call%E3%80%81apply%E3%80%81bind%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、用法 这三个方法都是 JavaScript 函数原型链上的方法，每个函数都会自动继承这三个方法。 总的来说三者都是用来改变this指向的，可以实现在一个对象的成员函数调用其它对象的成员函数或者成员变量。 123456789101112131415161718let jack = &#123; name:'jack', age:'23'&#125;let tom = &#123; name:'tom', age:'20', printMessage: function()&#123; console.log('This is ' + this.name + ',he is ' + this.age) &#125;&#125;tom.printMessage.call(jack); // 结果：This is jack,he is 23.tom.printMessage.apply(jack); // 结果：This is jack,he is 23.tom.printMessage.bind(jack)(); // 结果：This is jack,he is 23.// 可以看见printMessage内部的this指向被改变，不在指向调用它的对象tom，而是指向了call、apply、bind传入的参数：对象jack。 二、区别 这三个方法，在用途上没有什么区别，关键是在用法上存在区别。体现在他们三者的参数列表和返回值。 12345678910111213141516171819202122232425let jack = &#123; name: 'jack', age: '23'&#125;let tom = &#123; name: 'tom', age: '20', printMessage: function(from,to)&#123; console.log('This is ' + this.name + ',he is ' + this.age + 'from' + from + ' to ' + to + '.') &#125;&#125;// call方法，接受多个参数，第一个参数为执行函数的this值，其余参数将会按顺序赋值给执行函数的参数列表tom.printMessage.call(jack,'Beijin','Shanghai');// This is jack,he is 23 from Beijin to Shanghai/* apply方法，接受两个参数，第一个参数为执行函数的this值，第二个参数是一个数组，数组元素将会按顺序赋值给执行函数的参数列表 */tom.printMessage.apply(jack,['Beijin','Shanghai']);// This is jack,he is 23 from Beijin to Shanghai/* bind方法，接受参数形式与call方法一致，但是返回的是一个新的函数，必须要手动调用一次才会执行。*/tom.printMessage.bind(jack,'Beijin','Shanghai')();// This is jack,he is 23 from Beijin to Shanghai","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript中i++和++i的区别","slug":"JavaScript中i-和-i的区别","date":"2020-05-11T10:47:21.000Z","updated":"2020-05-11T13:00:59.496Z","comments":true,"path":"2020/05/11/JavaScript中i-和-i的区别/","link":"","permalink":"http://yoursite.com/2020/05/11/JavaScript%E4%B8%ADi-%E5%92%8C-i%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、++ i 和 i ++简单介绍++ 运算符又称自增运算符，功能为将操作数自加 1。 ++ i 被称为前加加，++ 后面的变量执行自加操作，执行顺序为：先执行变量的自加操作，再引用变量的值。 i ++ 被称为后加加，++ 前面的变量执行自加操作，执行顺序为：先引用变量的值，在执行自加操作。 在实际代码中，如果加加语句是一个独立的语句，那么两者是完全相同的。比如： 123a ++; /*完全等价于*/ ++ a;// orfor(let i = 0; i &lt; 10; i ++)&#123;...&#125; /*两者是完全等价的*/ for(let i = 0; i &lt; 10 ; ++ i)&#123;...&#125; 上面两个示例 自增语句都是一个独立的语句，在这种情况下，++ i和i ++是完全等价的。 二、 ++ i 和 i ++ 使用时的区别当加加语句不是一个独立的语句，只是某一个语句的一部分，二者就有区别了。 i ++ 12345let i = 0;let j = i ++; //此时完整的语句为 let j = i ++;先执行变量赋值，再执行 ++ 操作先j = i = 0 后i = 1;let i = 0;while( i ++ &lt; 10); // 此时i是从0开始第一次比较，先判断 i &lt; 10,然后变量i再执行加加操作; ++ i 12345let i = 0;let j = ++ i; //此时完整的语句为 let j = ++ i;先执行 ++ 操作，再赋值变量：先i = 1后j = i = 1;let i = 0;while( ++ i &lt; 10); // 此时i是从1开始第一次比较,变量i先执行加加操作，再判断 i &lt; 10;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"operator","slug":"JavaScript/operator","permalink":"http://yoursite.com/categories/JavaScript/operator/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"operator","slug":"operator","permalink":"http://yoursite.com/tags/operator/"}]},{"title":"Vue-cli@3中使用bootstrap","slug":"vue-import-bootstrap","date":"2020-05-07T16:38:49.000Z","updated":"2020-05-08T16:21:49.562Z","comments":true,"path":"2020/05/08/vue-import-bootstrap/","link":"","permalink":"http://yoursite.com/2020/05/08/vue-import-bootstrap/","excerpt":"","text":"Vue-cli@3创建的项目中如何使用Bootstrap一、安装所需包 Bootstrap 是基于 jQuery 开发的，所以先安装 jQuery。 1$ cnpm install jquery -s 安装 Popper.js, BootStrap 内部有些嵌套组件，是依靠 Popper.js 来实现定位的。非必须安装如果你的项目会用到 BootStrap 中的类似于 下拉列表这样的组件，建议先提前安装 popper.js,否则可能报错。关于popper.js的介绍以及具体介绍如下。 Popper.js是一款功能强大的JS定位引擎。 站在原型链顶端的男人的博客 1$ cnpm install popper.js -s 安装 BootStrap 包。 1$ cnpm install bootstrap@3 -s 二、配置main.js 全局引入 bootstrap 和 jquery 注意导入时，import $ from &#39;jquery&#39; 要写在最前面。否则可能报错 三、配置 vue.config.js 在 vue-cli@3搭建的 vue 项目默认是不没有该文件的，需要在 package.json 的同级目录下手动创建。具体代码如下： 如果一切顺利，便可以使用了。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Bootstrap","slug":"Vue/Bootstrap","permalink":"http://yoursite.com/categories/Vue/Bootstrap/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-04T00:50:58.975Z","updated":"2020-05-04T04:10:45.365Z","comments":true,"path":"2020/05/04/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}],"categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"layout","slug":"css/layout","permalink":"http://yoursite.com/categories/css/layout/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/categories/npm/"},{"name":"Node.js","slug":"npm/Node-js","permalink":"http://yoursite.com/categories/npm/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"},{"name":"operator","slug":"JavaScript/operator","permalink":"http://yoursite.com/categories/JavaScript/operator/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Bootstrap","slug":"Vue/Bootstrap","permalink":"http://yoursite.com/categories/Vue/Bootstrap/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"layout","slug":"layout","permalink":"http://yoursite.com/tags/layout/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"operator","slug":"operator","permalink":"http://yoursite.com/tags/operator/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}